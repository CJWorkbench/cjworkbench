import datetime
from typing import Any, Dict

from django.db import models
from django.utils import timezone

from .. import clientside


def jsonize_datetime(dt: datetime.datetime) -> str:
    return dt.isoformat().replace("+00:00", "Z")


class Block(models.Model):
    """Element in a Report.

    If (and only if) a Workflow's `.has_custom_report` is True, there can be
    zero or more Blocks. They are ordered by `.position` (first is 0).
    """

    class Meta:
        app_label = "server"
        db_table = "block"
        ordering = ["workflow_id", "position"]
        constraints = [
            models.CheckConstraint(
                check=(
                    models.Q(
                        block_type="Chart",
                        step_id__isnull=False,
                        tab_id__isnull=True,
                        text_markdown="",
                    )
                    | models.Q(
                        block_type="Table",
                        step_id__isnull=True,
                        tab_id__isnull=False,
                        text_markdown="",
                    )
                    | (
                        models.Q(
                            block_type="Text", step_id__isnull=True, tab_id__isnull=True
                        )
                        & ~models.Q(text_markdown="")
                    )
                ),
                name="block_type_nulls_check",
            ),
            models.UniqueConstraint(
                fields=["workflow", "slug"], name="unique_workflow_block_slugs"
            ),
            models.UniqueConstraint(
                fields=["workflow", "position"], name="unique_workflow_block_positions"
            ),
        ]

    workflow = models.ForeignKey(
        "server.Workflow", related_name="blocks", on_delete=models.CASCADE
    )

    slug = models.SlugField(db_index=True)
    """
    Unique ID, generated by the client.

    Within a Workflow, each Block has a different slug. The client randomly
    generates it so that the client can queue up requests that relate to it,
    before the Block is even created in the database (i.e., before it gets an
    ID). When duplicating a Workflow, we duplicate all its Blocks' slugs.
    """

    position = models.IntegerField()

    # use default, not auto_now_add, so we can set custom values in tests
    created_at = models.DateTimeField(default=timezone.now, editable=False)

    block_type = models.CharField(
        choices=[("Chart", "Chart"), ("Table", "Table"), ("Text", "Text")],
        max_length=5,
        editable=False,
    )

    text_markdown = models.TextField(blank=True)
    """Markdown, for a Text block."""

    tab = models.ForeignKey(
        "server.Tab",
        null=True,
        blank=True,
        related_name="blocks",
        on_delete=models.PROTECT,
    )
    """Tab, for a Table block.

    When deleting a Tab, you must explicitly delete its Blocks first.
    (Remember to store the Blocks in the undo history.)
    """

    step = models.ForeignKey(
        "server.Step",
        null=True,
        blank=True,
        related_name="blocks",
        on_delete=models.PROTECT,
    )
    """Step, for a Chart block.

    When deleting a Tab, you must explicitly delete its Blocks first.
    (Remember to store the Blocks in the undo history.)
    """

    def to_clientside(self) -> clientside.Block:
        if self.block_type == "Chart":
            return clientside.ChartBlock(self.step.slug)
        elif self.block_type == "Table":
            return clientside.TableBlock(self.tab.slug)
        elif self.block_type == "Text":
            return clientside.TextBlock(self.text_markdown)
        else:
            raise NotImplementedError

    def to_json_safe_kwargs(self) -> Dict[str, Any]:
        """Serialize for a future `workflow.blocks.create()` call.

        We store serialized Blocks in our undo history. The client never sees
        these values.
        """
        ret = {
            "slug": self.slug,
            "position": self.position,
            "created_at": jsonize_datetime(self.created_at),
            "block_type": self.block_type,
        }
        if self.block_type == "Chart":
            ret["step_slug"] = self.step.slug
        elif self.block_type == "Table":
            ret["tab_slug"] = self.tab.slug
        elif self.block_type == "Text":
            ret["text_markdown"] = self.text_markdown
        else:
            raise NotImplementedError
        return ret
