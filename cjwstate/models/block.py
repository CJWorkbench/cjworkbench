from __future__ import annotations

from typing import Any, Dict

from django.db import models

from .. import clientside


class BlockManager(models.Manager):
    def create(self, *, workflow, **kwargs) -> Block:
        from .step import Step

        if "step_slug" in kwargs:
            assert "step_id" not in kwargs and "step" not in kwargs
            step_slug = kwargs.pop("step_slug")
            kwargs["step_id"] = Step.live_in_workflow(workflow).get(slug=step_slug).id

        if "tab_slug" in kwargs:
            assert "tab_id" not in kwargs and "tab" not in kwargs
            tab_slug = kwargs.pop("tab_slug")
            kwargs["tab_id"] = workflow.live_tabs.get(slug=tab_slug).id

        return super().create(workflow=workflow, **kwargs)


class Block(models.Model):
    """Element in a Report.

    If (and only if) a Workflow's `.has_custom_report` is True, there can be
    zero or more Blocks. They are ordered by `.position` (first is 0).
    """

    class Meta:
        app_label = "cjworkbench"
        db_table = "block"
        ordering = ["workflow_id", "position"]
        constraints = [
            models.CheckConstraint(
                check=(
                    models.Q(
                        block_type="Chart",
                        step_id__isnull=False,
                        tab_id__isnull=True,
                        text_markdown="",
                    )
                    | models.Q(
                        block_type="Table",
                        step_id__isnull=True,
                        tab_id__isnull=False,
                        text_markdown="",
                    )
                    | (
                        models.Q(
                            block_type="Text", step_id__isnull=True, tab_id__isnull=True
                        )
                        & ~models.Q(text_markdown="")
                    )
                ),
                name="block_type_nulls_check",
            ),
            models.UniqueConstraint(
                fields=["workflow", "slug"], name="unique_workflow_block_slugs"
            ),
            models.UniqueConstraint(
                fields=["workflow", "position"], name="unique_workflow_block_positions"
            ),
        ]

    objects = BlockManager()

    workflow = models.ForeignKey(
        "cjworkbench.Workflow", related_name="blocks", on_delete=models.CASCADE
    )

    slug = models.SlugField(db_index=True)
    """
    Unique ID, generated by the client.

    Within a Workflow, each Block has a different slug. The client randomly
    generates it so that the client can queue up requests that relate to it,
    before the Block is even created in the database (i.e., before it gets an
    ID). When duplicating a Workflow, we duplicate all its Blocks' slugs.
    """

    position = models.IntegerField()

    block_type = models.CharField(
        choices=[("Chart", "Chart"), ("Table", "Table"), ("Text", "Text")],
        max_length=5,
        editable=False,
    )

    text_markdown = models.TextField(blank=True)
    """Markdown, for a Text block."""

    tab = models.ForeignKey(
        "cjworkbench.Tab",
        null=True,
        blank=True,
        related_name="blocks",
        on_delete=models.PROTECT,
    )
    """Tab, for a Table block.

    When deleting a Tab, you must explicitly delete its Blocks first.
    (Remember to store the Blocks in the undo history.)
    """

    step = models.ForeignKey(
        "cjworkbench.Step",
        null=True,
        blank=True,
        related_name="blocks",
        on_delete=models.PROTECT,
    )
    """Step, for a Chart block.

    When deleting a Tab, you must explicitly delete its Blocks first.
    (Remember to store the Blocks in the undo history.)
    """

    def to_clientside(self) -> clientside.Block:
        if self.block_type == "Chart":
            return clientside.ChartBlock(self.step.slug)
        elif self.block_type == "Table":
            return clientside.TableBlock(self.tab.slug)
        elif self.block_type == "Text":
            return clientside.TextBlock(self.text_markdown)
        else:
            raise NotImplementedError

    def to_json_safe_kwargs(self) -> Dict[str, Any]:
        """Serialize for a future `workflow.blocks.create()` call.

        We store serialized Blocks in our undo history. The client never sees
        these values.

        BlockManager.create() accepts these kwargs directly.
        """
        ret = {
            "slug": self.slug,
            "position": self.position,
            "block_type": self.block_type,
        }
        if self.block_type == "Chart":
            ret["step_slug"] = self.step.slug
        elif self.block_type == "Table":
            ret["tab_slug"] = self.tab.slug
        elif self.block_type == "Text":
            ret["text_markdown"] = self.text_markdown
        else:
            raise NotImplementedError
        return ret
