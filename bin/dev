#!/bin/bash
#
# Run a Dockerized development environment:
#
# * ./bin/dev-in-docker start: migrate once and start all services
# * ./bin/dev-in-docker python ./manage.py migrate: migrate database
# * ./bin/dev-in-docker pipenv install foo: run pipenv
# * ./bin/dev-in-docker test: run unit tests
# * ./bin/dev-in-docker npm install foo: run npm
# * ./bin/dev-in-docker stop: kill everything
#
# In broad strokes:
#
# * Each service is its own process, prefixed with "cjworkbench_dev"
# * We volume-mount excessively: for instance, node_modules is mounted
# * Running ./manage.py or npm creates a new container that mounts the same
#   volumes.

set -e
#set -x

docker_compose() {
  docker-compose "$@"
}

cd "$(dirname "$0")"/..

# docker-compose with overrides
#
# https://github.com/docker/compose/issues/1896 gives docker-compose's rationale
# for keeping our 'migrate' and 'test' runners outside of docker-compose.yml.
docker_compose_with_commands() {
  docker-compose \
    -f docker-compose.yml \
    -f docker-compose.commands.yml \
    "$@"
}

print_usage() {
  echo "Usage: $0 COMMAND ARGS..." >&2
  echo >&2
  echo 'Where COMMAND is one of:' >&2
  echo '  clean -- wipe all data' >&2
  echo '  develop-module DIR -- run "./manage.py develop-module DIR"' >&2
  echo '  npm ARGS -- run "npm ARGS..." in a Node environment' >&2
  echo '  pipenv ARGS -- run "pipenv ARGS..." in a Python environment' >&2
  echo '  python ARGS -- run "pipenv run python ARGS..." in a Python environment' >&2
  echo '  pybabel ARGS -- run "pipenv run pybabel ARGS..." in a Python environment' >&2
  echo '  extract-messages -- extract translation messages from js, python, and templates and merge them into one file per locale' >&2
  echo '  reformat-code -- make code conform to (Black) styleguide' >&2
  echo '  run SERVICE ARGS -- run "docker-compose run -rm SERVICE ARGS..."' >&2
  echo '  quickstart -- start database, RabbitMQ, Webpack and Django without updates' >&2
  echo '  sql -- open a psql prompt in the dev database (it must be up)' >&2
  echo '  start -- start database, RabbitMQ, Webpack and Django' >&2
  echo '  stop -- stop services created by start' >&2
  echo '  test-sql -- open a psql prompt in the test database (it must be up)' >&2
  echo '  thrift ARGS -- run "thrift ARGS..." (see cjwkernel/thrift/)' >&2
  echo '  unittest ARGS -- run "./manage.py test ARGS..."' >&2
}

COMMAND="$1"
shift || true

case "$COMMAND" in
  "clean")
    # Delete all files.
    #
    # Why use docker? Because files written by Docker are owned by root, so
    # `rm local_mail/*` will fail if we run outside of Docker.
    #
    # Why use docker-compose instead of, say, `docker run --rm alpine:3.8`?
    # Because mounting this directory as a volume requires an absolute path,
    # and finding the absolute path takes different logic on Windows than on
    # non-Windows.
    #
    # docker-compose is much slower, but it takes fewer lines of code.
    docker_compose_with_commands run --rm pydev rm -rf local_mail/*

    # Wipe volumes
    docker_compose_with_commands down -t0 -v # -v removes named volumes
    docker_compose_with_commands rm -f -v # -v removes _anonymous_ volumes
    ;;

  "exec")
    docker_compose exec "$@"
    ;;

  "npm")
    docker_compose run --rm webpack npm "$@"
    ;;

  "python")
    docker_compose_with_commands run --rm pydev pipenv run python "$@"
    ;;

  "pipenv"|"thrift")
    docker_compose_with_commands run --rm pydev "$COMMAND" "$@"
    ;;

  "pybabel")
    # For some weird reason, pybabel can't find our source files
    # even when run with our project root as working directory.
    # Works if we set `PYTHONPATH` to `.` (maybe `PYTHONPATH` is overriden somewhere?) 
    docker_compose_with_commands run --rm -e PYTHONPATH=. pydev pipenv run pybabel "$@"
    ;;

  "extract-messages")
    docker_compose_with_commands run --rm -e PYTHONPATH=. pydev pipenv run python cjworkbench/i18n/merge_catalogs.py prepare
    
    docker_compose run --rm webpack npm run extract -- --clean
    
    # 0. This must come after `npm run extract`, since `npm run extract` 
    #    comments out any messages it can't find in js code
    # 1. For PYTHONPATH, ditto `pybabel` command above
    # 2. We want pybabel to extract default messages in single-line comments, 
    #    hence we must disable line wrapping when extracting.
    #    However, looks like `--no-wrap` does not work for comments, 
    #    so we have to set a big enough max line width to fit every (even remotely) sensible default message 
    # 3. We extract the pot file in the directory of our source locale,
    #    for pontoon to find
    docker_compose_with_commands run --rm -e PYTHONPATH=. pydev pipenv run pybabel extract \
        -w 10000000 -F pybabel.cfg \
        -o assets/locale/en/messages.pot . 
        
    # for PYTHONPATH, ditto `pybabel` command above
    docker_compose_with_commands run --rm -e PYTHONPATH=. pydev pipenv run python cjworkbench/i18n/merge_catalogs.py
    ;;

  "unittest")
    # Overwrite the "command" so we can incorporate "$@".
    docker_compose_with_commands run --rm unittest sh -c 'while ! curl --silent -I $MINIO_URL >/dev/null; do sleep 0.1; done; mc config host add workbench $MINIO_URL minio_root_access minio_root_secret && mc admin user add workbench $MINIO_ACCESS_KEY $MINIO_SECRET_KEY && mc admin policy set workbench readwrite user=$MINIO_ACCESS_KEY'
    docker_compose_with_commands run --rm unittest pipenv run python ./manage.py test "$@"
    ;;

  "develop-module")
    MODULE="$1" docker_compose_with_commands run --rm develop-module pipenv run python ./manage.py develop-module ../"$1"
    exit 1
    ;;

  "sql")
    docker_compose exec database psql -U cjworkbench "$@"
    ;;

  "test-sql")
    docker_compose exec testdatabase psql -U cjworkbench "$@"
    ;;

  "reformat-code")
    docker_compose_with_commands run --rm pydev pipenv run black .
    docker_compose run --rm webpack npm run reformat-code
    ;;

  "start")
    # Make sure every dev has the same versions of Python/Node by pulling
    docker_compose_with_commands build --pull

    # Make sure Python deps are up to date; migrate database
    docker_compose_with_commands run --rm migrate

    # Make sure JavaScript deps are up to date
    docker_compose run --rm webpack npm install

    # Start Django and Webpack
    docker_compose up -t0 --abort-on-container-exit
    ;;

  "quickstart")
    # Start Django and Webpack
    docker_compose up -t0 --abort-on-container-exit
    ;;

  "stop")
    docker_compose_with_commands down -t0
    docker_compose_with_commands rm -f -v # -v removes _anonymous_ volumes
    ;;

  "run")
    docker_compose_with_commands run --rm "$@"
    ;;

  *)
    print_usage
    exit 1
    ;;
esac
