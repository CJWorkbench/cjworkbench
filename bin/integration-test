#!/bin/bash

set -e
#set -x

cd "$(dirname "$0")"/..

docker_compose() {
  docker-compose \
    -p 'cjworkbench_integrationtest' \
    -f integrationtests/docker-compose.yml \
    -f integrationtests/docker-compose.dev-override.yml \
    "$@"
}

debugging_ideas() {
  cat <<EOT

DEBUGGING IDEAS

1. Blindly fix bugs in the integration tests

    a. Edit code in integrationtests/
    b. Run \`$0 resume\` to run tests without changing the system under test

2. Watch tests using VNC

    a. Run \`$0 shell\` to start a new test runner
    b. Connect a VNC client to localhost:5901
    c. In the test-runner shell, run \`python -m unittest discover integrationtests\`
    d1. If the bug is in a test, edit and re-run python (integrationtests/ is mounted)
    d2. If the bug is in Workbench, write a unit-test and restart from scratch
    d3. Still not finding the bug? Run \`firefox\` and test in your VNC client
EOT
}

if [ "$1" = "shell" ]; then
  docker_compose run --rm \
    --service-ports \
    integration-test \
    bash -c '/app/integrationtests/start-vnc & DISPLAY=:1 bash'
  exit 0
elif [ "$1" = "resume" ]; then
  if docker_compose run integration-test; then
    echo 'Tests passed! We left everything running because you resumed.' >&2
    exit 0
  else
    echo 'Tests failed, and we left everything running.' >&2
    debugging_ideas >&2
    exit 1
  fi
elif [ -n "$1" ]; then
  echo "Usage: $0 [shell|resume]" >&2
  exit 1
fi

echo 'Tearing down old environment (if it exists)…' >&2
docker_compose down -v

echo 'Building…' >&2
# docker_compose doesn't use buildkit.
# https://github.com/docker/compose/issues/6440
#
# In the meantime, `docker-compose build --pull` is super-inefficient: it pulls
# from scratch on every single image. And `docker-compose build --parallel` is
# even worse: it will run the exact same build steps in each build process,
# simultaneously.
#
# So let's "pull once, run everywhere". Grab dependencies using `docker pull`,
# then build using `docker-compose` without pulling.
#
# We can find all dependencies in our Dockerfiles:
#   * Each dependency is in Dockerfile with a 'FROM xxx AS yyy" command
#   * Multi-stage builds often depend on internal names. External images all
#     have ':' in their names: for instance, 'debian:buster-slim' is external;
#     'pybase' is internal.
#   * "sort -u" removes duplicates
for image in $(grep '^FROM .*:.*' Dockerfile Dockerfile.integrationtest | cut -d' ' -f2 | sort -u); do
  docker pull $image
done

# Now docker-compose needn't --pull
docker_compose build

echo 'Creating minio user…' >&2
docker_compose run addminiouser

echo 'Migrating (and starting database and RabbitMQ)…' >&2
docker_compose run migrate

echo 'Testing (and starting test environment)…' >&2
if docker_compose run integration-test; then
  echo 'Tests passed!' >&2
  docker_compose down -v
else
  echo 'Tests failed, so we left everything running.' >&2
  debugging_ideas >&2
  exit 1
fi
