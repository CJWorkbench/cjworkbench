#
# Autogenerated by Thrift Compiler (0.11.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:slots
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys

from thrift.transport import TTransport
all_structs = []


class ModuleErrorCompileError(object):
    """
    The module's code is invalid, as per its programming language.

    Attributes:
     - message: Compiler error message.
    """

    __slots__ = (
        'message',
    )


    def __init__(self, message=None,):
        self.message = message

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.message = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ModuleErrorCompileError')
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRING, 1)
            oprot.writeString(self.message.encode('utf-8') if sys.version_info[0] == 2 else self.message)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class ModuleErrorTimeout(object):
    """
    A module's code took too long to execute.

    Attributes:
     - max_seconds: How long we were configured to wait.
     - log: Last few lines of console output before termination.
    """

    __slots__ = (
        'max_seconds',
        'log',
    )


    def __init__(self, max_seconds=None, log=None,):
        self.max_seconds = max_seconds
        self.log = log

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.DOUBLE:
                    self.max_seconds = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.log = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ModuleErrorTimeout')
        if self.max_seconds is not None:
            oprot.writeFieldBegin('max_seconds', TType.DOUBLE, 1)
            oprot.writeDouble(self.max_seconds)
            oprot.writeFieldEnd()
        if self.log is not None:
            oprot.writeFieldBegin('log', TType.STRING, 2)
            oprot.writeString(self.log.encode('utf-8') if sys.version_info[0] == 2 else self.log)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class ModuleErrorExited(object):
    """
    A module's code terminated unexpectedly.

    Attributes:
     - exit_code: Exit code; must be non-zero.

    Exit code 137 means we were sent 'kill -9' ... which often means, "out of
    memory".
     - log: Last few lines of console output before exit.
    """

    __slots__ = (
        'exit_code',
        'log',
    )


    def __init__(self, exit_code=None, log=None,):
        self.exit_code = exit_code
        self.log = log

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.exit_code = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.log = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ModuleErrorExited')
        if self.exit_code is not None:
            oprot.writeFieldBegin('exit_code', TType.I16, 1)
            oprot.writeI16(self.exit_code)
            oprot.writeFieldEnd()
        if self.log is not None:
            oprot.writeFieldBegin('log', TType.STRING, 2)
            oprot.writeString(self.log.encode('utf-8') if sys.version_info[0] == 2 else self.log)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class ValidateModuleResultOk(object):
    """
    Validation of a kernel module's code succeeded.

    This value cannot be trusted: a malicious module may report that it is ok.
    (Indeed, many buggy modules _will_ self-report as ok.)
    """

    __slots__ = (
    )


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ValidateModuleResultOk')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class ValidateModuleResultError(object):
    """
    Validation of a kernel module's code failed.

    `compile_error` and `timeout` can be trusted: a malicious module cannot
    fake them. `exited` can be manipulated by a malicious module, though there
    doesn't seem to be much point.

    Attributes:
     - compile_error: The kernel module's code cannot be run.
     - timeout: The kernel module's code took too long to run.

    In Python code, this can happen if there's a long-running block of code at
    the top level of the module.
     - exited: The kernel module's code exited with a non-zero exit code.

    During module load, Workbench will execute the module code. The module
    will then self-validate and exit with status code 1 if it detects, say,
    that its `render()` function has the wrong signature.

    Do not trust this return value: it is returned by the module itself after
    user code was run. The intent is for well-meaning code to self-diagnose
    with a helpful error message. Malicious code will ... uh ...
    self-diagnose with an *un*-helpful error message.
    """

    __slots__ = (
        'compile_error',
        'timeout',
        'exited',
    )


    def __init__(self, compile_error=None, timeout=None, exited=None,):
        self.compile_error = compile_error
        self.timeout = timeout
        self.exited = exited

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.compile_error = ModuleErrorCompileError()
                    self.compile_error.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.timeout = ModuleErrorTimeout()
                    self.timeout.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.exited = ModuleErrorExited()
                    self.exited.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ValidateModuleResultError')
        if self.compile_error is not None:
            oprot.writeFieldBegin('compile_error', TType.STRUCT, 1)
            self.compile_error.write(oprot)
            oprot.writeFieldEnd()
        if self.timeout is not None:
            oprot.writeFieldBegin('timeout', TType.STRUCT, 2)
            self.timeout.write(oprot)
            oprot.writeFieldEnd()
        if self.exited is not None:
            oprot.writeFieldBegin('exited', TType.STRUCT, 3)
            self.exited.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class ValidateModuleResult(object):
    """
    Result of attempting to load and run module code.

    An `ok` result does not mean the module can be _trusted_. No module code can
    be trusted. An `error` result _always_ means the module can't be trusted.

    Attributes:
     - ok
     - error
    """

    __slots__ = (
        'ok',
        'error',
    )


    def __init__(self, ok=None, error=None,):
        self.ok = ok
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ok = ValidateModuleResultOk()
                    self.ok.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.error = ValidateModuleResultError()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ValidateModuleResult')
        if self.ok is not None:
            oprot.writeFieldBegin('ok', TType.STRUCT, 1)
            self.ok.write(oprot)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 2)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class ColumnTypeText(object):
    """
    A "text"-typed column.
    """

    __slots__ = (
    )


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ColumnTypeText')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class ColumnTypeNumber(object):
    """
    A "number"-typed column.

    Attributes:
     - format: Python-syntax number format, like `{,.2%}`
    """

    __slots__ = (
        'format',
    )


    def __init__(self, format="{:,}",):
        self.format = format

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.format = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ColumnTypeNumber')
        if self.format is not None:
            oprot.writeFieldBegin('format', TType.STRING, 1)
            oprot.writeString(self.format.encode('utf-8') if sys.version_info[0] == 2 else self.format)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class ColumnTypeDatetime(object):
    """
    A "datetime"-typed column.
    """

    __slots__ = (
    )


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ColumnTypeDatetime')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class ColumnType(object):
    """
    The type (and its options) of a column.

    This is the _user-visible_ type. We do not store the bit layout. For
    instance, we store "number" and not "i32" or "i64".

    Attributes:
     - text_type
     - number_type
     - datetime_type
    """

    __slots__ = (
        'text_type',
        'number_type',
        'datetime_type',
    )


    def __init__(self, text_type=None, number_type=None, datetime_type=None,):
        self.text_type = text_type
        self.number_type = number_type
        self.datetime_type = datetime_type

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.text_type = ColumnTypeText()
                    self.text_type.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.number_type = ColumnTypeNumber()
                    self.number_type.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.datetime_type = ColumnTypeDatetime()
                    self.datetime_type.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ColumnType')
        if self.text_type is not None:
            oprot.writeFieldBegin('text_type', TType.STRUCT, 1)
            self.text_type.write(oprot)
            oprot.writeFieldEnd()
        if self.number_type is not None:
            oprot.writeFieldBegin('number_type', TType.STRUCT, 2)
            self.number_type.write(oprot)
            oprot.writeFieldEnd()
        if self.datetime_type is not None:
            oprot.writeFieldBegin('datetime_type', TType.STRUCT, 3)
            self.datetime_type.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class Column(object):
    """
    Description of a column in a table.

    Attributes:
     - name: Name of the column (unique among all columns in the table).
     - type: Date type the user will see.
    """

    __slots__ = (
        'name',
        'type',
    )


    def __init__(self, name=None, type=None,):
        self.name = name
        self.type = type

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.type = ColumnType()
                    self.type.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Column')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.STRUCT, 2)
            self.type.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class ArrowTable(object):
    """
    Table stored on disk, ready to be mmapped.

    The file on disk is `{tab_slug}.arrow`, in a directory agreed upon by the
    processes passing this data around.

    Attributes:
     - tab_slug: Unique tab identifier.

    There must be a valid Arrow file on disk named after `tab_slug`.
     - columns: Columns in the table.

    The Arrow file's columns must agree with these columns.
    """

    __slots__ = (
        'tab_slug',
        'columns',
    )


    def __init__(self, tab_slug=None, columns=None,):
        self.tab_slug = tab_slug
        self.columns = columns

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.tab_slug = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.columns = []
                    (_etype3, _size0) = iprot.readListBegin()
                    for _i4 in range(_size0):
                        _elem5 = Column()
                        _elem5.read(iprot)
                        self.columns.append(_elem5)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ArrowTable')
        if self.tab_slug is not None:
            oprot.writeFieldBegin('tab_slug', TType.STRING, 1)
            oprot.writeString(self.tab_slug.encode('utf-8') if sys.version_info[0] == 2 else self.tab_slug)
            oprot.writeFieldEnd()
        if self.columns is not None:
            oprot.writeFieldBegin('columns', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.columns))
            for iter6 in self.columns:
                iter6.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class Params(object):
    """
    Module `render()` and `fetch()` parameters.

    Attributes:
     - json: JSON-encoded dictionary of values.

    Must be a valid JSON dictionary.
    """

    __slots__ = (
        'json',
    )


    def __init__(self, json=None,):
        self.json = json

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.json = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Params')
        if self.json is not None:
            oprot.writeFieldBegin('json', TType.STRING, 1)
            oprot.writeString(self.json.encode('utf-8') if sys.version_info[0] == 2 else self.json)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class Tab(object):
    """
    Tab description.

    Attributes:
     - slug: Tab identifier, unique in its Workflow.
     - name: Tab name, provided by the user.
    """

    __slots__ = (
        'slug',
        'name',
    )


    def __init__(self, slug=None, name=None,):
        self.slug = slug
        self.name = name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.slug = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Tab')
        if self.slug is not None:
            oprot.writeFieldBegin('slug', TType.STRING, 1)
            oprot.writeString(self.slug.encode('utf-8') if sys.version_info[0] == 2 else self.slug)
            oprot.writeFieldEnd()
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 2)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class TabResult(object):
    """
    Already-computed output of a tab.

    During workflow execute, the output from one tab can be used as the input to
    another.

    Attributes:
     - tab: Tab that was processed.
     - result: Output from the final Step in `tab`.

    RenderResultOk may indicate a user-facing error in the other tab.

    If the other tab's result was a RenderResultError, that will be wrapped
    to become a RenderResultOk here.
    """

    __slots__ = (
        'tab',
        'result',
    )


    def __init__(self, tab=None, result=None,):
        self.tab = tab
        self.result = result

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.tab = Tab()
                    self.tab.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.result = RenderResultOk()
                    self.result.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TabResult')
        if self.tab is not None:
            oprot.writeFieldBegin('tab', TType.STRUCT, 1)
            self.tab.write(oprot)
            oprot.writeFieldEnd()
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.STRUCT, 2)
            self.result.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class I18nArgument(object):
    """
    Argument to a translatable string.

    Attributes:
     - string_value
     - i32_value
     - double_value
    """

    __slots__ = (
        'string_value',
        'i32_value',
        'double_value',
    )


    def __init__(self, string_value=None, i32_value=None, double_value=None,):
        self.string_value = string_value
        self.i32_value = i32_value
        self.double_value = double_value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.string_value = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.i32_value = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.double_value = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('I18nArgument')
        if self.string_value is not None:
            oprot.writeFieldBegin('string_value', TType.STRING, 1)
            oprot.writeString(self.string_value.encode('utf-8') if sys.version_info[0] == 2 else self.string_value)
            oprot.writeFieldEnd()
        if self.i32_value is not None:
            oprot.writeFieldBegin('i32_value', TType.I32, 2)
            oprot.writeI32(self.i32_value)
            oprot.writeFieldEnd()
        if self.double_value is not None:
            oprot.writeFieldBegin('double_value', TType.DOUBLE, 3)
            oprot.writeDouble(self.double_value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class I18nMessage(object):
    """
    Translation key and arguments.

    Attributes:
     - id: Message ID. For instance, `modules.renamecolumns.duplicateColname`
     - arguments: Arguments (if Message ID takes any).

    For instance, `["Old Name", "New Name"]`.
    """

    __slots__ = (
        'id',
        'arguments',
    )


    def __init__(self, id=None, arguments=None,):
        self.id = id
        self.arguments = arguments

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.id = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.arguments = []
                    (_etype10, _size7) = iprot.readListBegin()
                    for _i11 in range(_size7):
                        _elem12 = I18nArgument()
                        _elem12.read(iprot)
                        self.arguments.append(_elem12)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('I18nMessage')
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.STRING, 1)
            oprot.writeString(self.id.encode('utf-8') if sys.version_info[0] == 2 else self.id)
            oprot.writeFieldEnd()
        if self.arguments is not None:
            oprot.writeFieldBegin('arguments', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.arguments))
            for iter13 in self.arguments:
                iter13.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class PrependStepQuickFixAction(object):
    """
    Instruction that upon clicking a button, Workbench should create a Step.

    Attributes:
     - module_slug: Module to prepend.
     - partial_params: Some params to set on the new Step (atop the module's defaults).
    """

    __slots__ = (
        'module_slug',
        'partial_params',
    )


    def __init__(self, module_slug=None, partial_params=None,):
        self.module_slug = module_slug
        self.partial_params = partial_params

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.module_slug = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.partial_params = Params()
                    self.partial_params.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('PrependStepQuickFixAction')
        if self.module_slug is not None:
            oprot.writeFieldBegin('module_slug', TType.STRING, 1)
            oprot.writeString(self.module_slug.encode('utf-8') if sys.version_info[0] == 2 else self.module_slug)
            oprot.writeFieldEnd()
        if self.partial_params is not None:
            oprot.writeFieldBegin('partial_params', TType.STRUCT, 2)
            self.partial_params.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class QuickFixAction(object):
    """
    Instruction for what happens when the user clicks a Quick Fix button.

    Attributes:
     - prepend_step: Clicking the button will add a Step before the button's Step.
    """

    __slots__ = (
        'prepend_step',
    )


    def __init__(self, prepend_step=None,):
        self.prepend_step = prepend_step

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.prepend_step = PrependStepQuickFixAction()
                    self.prepend_step.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('QuickFixAction')
        if self.prepend_step is not None:
            oprot.writeFieldBegin('prepend_step', TType.STRUCT, 1)
            self.prepend_step.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class QuickFix(object):
    """
    Button the user can click in response to an error message.

    Attributes:
     - button_text
     - action
    """

    __slots__ = (
        'button_text',
        'action',
    )


    def __init__(self, button_text=None, action=None,):
        self.button_text = button_text
        self.action = action

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.button_text = I18nMessage()
                    self.button_text.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.action = QuickFixAction()
                    self.action.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('QuickFix')
        if self.button_text is not None:
            oprot.writeFieldBegin('button_text', TType.STRUCT, 1)
            self.button_text.write(oprot)
            oprot.writeFieldEnd()
        if self.action is not None:
            oprot.writeFieldBegin('action', TType.STRUCT, 2)
            self.action.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class RenderError(object):
    """
    Error or warning encountered during `render()`.

    If `render()` output is a zero-column table, then its result's errors are
    "errors" -- they prevent the workflow from executing. If `render()` outputs
    columns, though, then its result's errors are "warnings" -- execution
    continues and these messages are presented to the user.

    Attributes:
     - message
     - quick_fixes
    """

    __slots__ = (
        'message',
        'quick_fixes',
    )


    def __init__(self, message=None, quick_fixes=None,):
        self.message = message
        self.quick_fixes = quick_fixes

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.message = I18nMessage()
                    self.message.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.quick_fixes = []
                    (_etype17, _size14) = iprot.readListBegin()
                    for _i18 in range(_size14):
                        _elem19 = QuickFix()
                        _elem19.read(iprot)
                        self.quick_fixes.append(_elem19)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RenderError')
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRUCT, 1)
            self.message.write(oprot)
            oprot.writeFieldEnd()
        if self.quick_fixes is not None:
            oprot.writeFieldBegin('quick_fixes', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.quick_fixes))
            for iter20 in self.quick_fixes:
                iter20.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class RenderResultOk(object):
    """
    The module executed a Step's render() without crashing.

    An "ok" result may be a user-friendly error -- that is, a zero-column table
    and non-empty `errors`.

    Attributes:
     - table: Table the Step outputs.

    If the Step output is "error, then the table must have zero columns.
     - errors: User-facing errors or warnings reported by the module.
     - json: JSON to pass to the module's HTML, if it has HTML.

    This must be either an empty string, or a valid JSON value.
    """

    __slots__ = (
        'table',
        'errors',
        'json',
    )


    def __init__(self, table=None, errors=None, json="",):
        self.table = table
        self.errors = errors
        self.json = json

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.table = ArrowTable()
                    self.table.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.errors = []
                    (_etype24, _size21) = iprot.readListBegin()
                    for _i25 in range(_size21):
                        _elem26 = RenderError()
                        _elem26.read(iprot)
                        self.errors.append(_elem26)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.json = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RenderResultOk')
        if self.table is not None:
            oprot.writeFieldBegin('table', TType.STRUCT, 1)
            self.table.write(oprot)
            oprot.writeFieldEnd()
        if self.errors is not None:
            oprot.writeFieldBegin('errors', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.errors))
            for iter27 in self.errors:
                iter27.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.json is not None:
            oprot.writeFieldBegin('json', TType.STRING, 3)
            oprot.writeString(self.json.encode('utf-8') if sys.version_info[0] == 2 else self.json)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class RenderResultErrorInvalidOutput(object):
    """
    The module executed, but its output did not pass validation.

    This is always a bug in the module code. Module code must always return
    RenderResultOk and then exit. Here are the errors a module may have that
    would cause "invalid output":

    * The module did not write exactly one object to its output channel.
    * The module wrote a non-RenderResultOk object to the output channel.
    * The module wrote RenderResultOk, but its `table` or `json` were invalid.

    Attributes:
     - message
    """

    __slots__ = (
        'message',
    )


    def __init__(self, message=None,):
        self.message = message

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.message = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RenderResultErrorInvalidOutput')
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRING, 1)
            oprot.writeString(self.message.encode('utf-8') if sys.version_info[0] == 2 else self.message)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class RenderResultError(object):
    """
    A bug in the module prevented this Step from completing.

    This should always email someone. Buggy modules affect users.

    Attributes:
     - invalid_output: The module exited with exit code 0 but did not write valid output.
     - timeout: The module did not exit in time.
     - exited: The module exited with a non-zero status code.
    """

    __slots__ = (
        'invalid_output',
        'timeout',
        'exited',
    )


    def __init__(self, invalid_output=None, timeout=None, exited=None,):
        self.invalid_output = invalid_output
        self.timeout = timeout
        self.exited = exited

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.invalid_output = RenderResultErrorInvalidOutput()
                    self.invalid_output.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.timeout = ModuleErrorTimeout()
                    self.timeout.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.exited = ModuleErrorExited()
                    self.exited.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RenderResultError')
        if self.invalid_output is not None:
            oprot.writeFieldBegin('invalid_output', TType.STRUCT, 1)
            self.invalid_output.write(oprot)
            oprot.writeFieldEnd()
        if self.timeout is not None:
            oprot.writeFieldBegin('timeout', TType.STRUCT, 2)
            self.timeout.write(oprot)
            oprot.writeFieldEnd()
        if self.exited is not None:
            oprot.writeFieldBegin('exited', TType.STRUCT, 3)
            self.exited.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class RenderResult(object):
    """
    The outcome of a call to `render()`.

    Attributes:
     - ok: The module did not crash.

    (This could be an error message for the user.)
     - error: The module crashed.

    This is always a bug. Email someone.
    """

    __slots__ = (
        'ok',
        'error',
    )


    def __init__(self, ok=None, error=None,):
        self.ok = ok
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ok = RenderResultOk()
                    self.ok.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.error = RenderResultError()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RenderResult')
        if self.ok is not None:
            oprot.writeFieldBegin('ok', TType.STRUCT, 1)
            self.ok.write(oprot)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 2)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(ModuleErrorCompileError)
ModuleErrorCompileError.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'message', 'UTF8', None, ),  # 1
)
all_structs.append(ModuleErrorTimeout)
ModuleErrorTimeout.thrift_spec = (
    None,  # 0
    (1, TType.DOUBLE, 'max_seconds', None, None, ),  # 1
    (2, TType.STRING, 'log', 'UTF8', None, ),  # 2
)
all_structs.append(ModuleErrorExited)
ModuleErrorExited.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'exit_code', None, None, ),  # 1
    (2, TType.STRING, 'log', 'UTF8', None, ),  # 2
)
all_structs.append(ValidateModuleResultOk)
ValidateModuleResultOk.thrift_spec = (
)
all_structs.append(ValidateModuleResultError)
ValidateModuleResultError.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'compile_error', [ModuleErrorCompileError, None], None, ),  # 1
    (2, TType.STRUCT, 'timeout', [ModuleErrorTimeout, None], None, ),  # 2
    (3, TType.STRUCT, 'exited', [ModuleErrorExited, None], None, ),  # 3
)
all_structs.append(ValidateModuleResult)
ValidateModuleResult.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ok', [ValidateModuleResultOk, None], None, ),  # 1
    (2, TType.STRUCT, 'error', [ValidateModuleResultError, None], None, ),  # 2
)
all_structs.append(ColumnTypeText)
ColumnTypeText.thrift_spec = (
)
all_structs.append(ColumnTypeNumber)
ColumnTypeNumber.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'format', 'UTF8', "{:,}", ),  # 1
)
all_structs.append(ColumnTypeDatetime)
ColumnTypeDatetime.thrift_spec = (
)
all_structs.append(ColumnType)
ColumnType.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'text_type', [ColumnTypeText, None], None, ),  # 1
    (2, TType.STRUCT, 'number_type', [ColumnTypeNumber, None], None, ),  # 2
    (3, TType.STRUCT, 'datetime_type', [ColumnTypeDatetime, None], None, ),  # 3
)
all_structs.append(Column)
Column.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'type', [ColumnType, None], None, ),  # 2
)
all_structs.append(ArrowTable)
ArrowTable.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'tab_slug', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'columns', (TType.STRUCT, [Column, None], False), None, ),  # 2
)
all_structs.append(Params)
Params.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'json', 'UTF8', None, ),  # 1
)
all_structs.append(Tab)
Tab.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'slug', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'name', 'UTF8', None, ),  # 2
)
all_structs.append(TabResult)
TabResult.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'tab', [Tab, None], None, ),  # 1
    (2, TType.STRUCT, 'result', [RenderResultOk, None], None, ),  # 2
)
all_structs.append(I18nArgument)
I18nArgument.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'string_value', 'UTF8', None, ),  # 1
    (2, TType.I32, 'i32_value', None, None, ),  # 2
    (3, TType.DOUBLE, 'double_value', None, None, ),  # 3
)
all_structs.append(I18nMessage)
I18nMessage.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'id', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'arguments', (TType.STRUCT, [I18nArgument, None], False), None, ),  # 2
)
all_structs.append(PrependStepQuickFixAction)
PrependStepQuickFixAction.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'module_slug', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'partial_params', [Params, None], None, ),  # 2
)
all_structs.append(QuickFixAction)
QuickFixAction.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'prepend_step', [PrependStepQuickFixAction, None], None, ),  # 1
)
all_structs.append(QuickFix)
QuickFix.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'button_text', [I18nMessage, None], None, ),  # 1
    (2, TType.STRUCT, 'action', [QuickFixAction, None], None, ),  # 2
)
all_structs.append(RenderError)
RenderError.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'message', [I18nMessage, None], None, ),  # 1
    (2, TType.LIST, 'quick_fixes', (TType.STRUCT, [QuickFix, None], False), None, ),  # 2
)
all_structs.append(RenderResultOk)
RenderResultOk.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'table', [ArrowTable, None], None, ),  # 1
    (2, TType.LIST, 'errors', (TType.STRUCT, [RenderError, None], False), None, ),  # 2
    (3, TType.STRING, 'json', 'UTF8', "", ),  # 3
)
all_structs.append(RenderResultErrorInvalidOutput)
RenderResultErrorInvalidOutput.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'message', 'UTF8', None, ),  # 1
)
all_structs.append(RenderResultError)
RenderResultError.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'invalid_output', [RenderResultErrorInvalidOutput, None], None, ),  # 1
    (2, TType.STRUCT, 'timeout', [ModuleErrorTimeout, None], None, ),  # 2
    (3, TType.STRUCT, 'exited', [ModuleErrorExited, None], None, ),  # 3
)
all_structs.append(RenderResult)
RenderResult.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ok', [RenderResultOk, None], None, ),  # 1
    (2, TType.STRUCT, 'error', [RenderResultError, None], None, ),  # 2
)
fix_spec(all_structs)
del all_structs
