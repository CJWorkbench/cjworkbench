#
# Autogenerated by Thrift Compiler (0.13.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:slots
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys

from thrift.transport import TTransport
all_structs = []


class ValidateModuleResult(object):
    """
    Validation of a kernel module's code succeeded.

    This value cannot be trusted: a malicious module may report that it is ok.
    (Indeed, many buggy modules _will_ self-report as ok.)

    """

    __slots__ = (
    )


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ValidateModuleResult')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class MigrateParamsResult(object):
    """
    Migrating params succeeded.

    Attributes:
     - params

    """

    __slots__ = (
        'params',
    )


    def __init__(self, params=None,):
        self.params = params

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.MAP:
                    self.params = {}
                    (_ktype1, _vtype2, _size0) = iprot.readMapBegin()
                    for _i4 in range(_size0):
                        _key5 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val6 = Json()
                        _val6.read(iprot)
                        self.params[_key5] = _val6
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('MigrateParamsResult')
        if self.params is not None:
            oprot.writeFieldBegin('params', TType.MAP, 1)
            oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.params))
            for kiter7, viter8 in self.params.items():
                oprot.writeString(kiter7.encode('utf-8') if sys.version_info[0] == 2 else kiter7)
                viter8.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class Json(object):
    """
    JSON-compatible value.

    Attributes:
     - string_value
     - int64_value
     - number_value
     - boolean_value
     - array_value
     - object_value

    """

    __slots__ = (
        'string_value',
        'int64_value',
        'number_value',
        'boolean_value',
        'array_value',
        'object_value',
    )


    def __init__(self, string_value=None, int64_value=None, number_value=None, boolean_value=None, array_value=None, object_value=None,):
        self.string_value = string_value
        self.int64_value = int64_value
        self.number_value = number_value
        self.boolean_value = boolean_value
        self.array_value = array_value
        self.object_value = object_value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.string_value = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.int64_value = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.number_value = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.boolean_value = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.array_value = []
                    (_etype12, _size9) = iprot.readListBegin()
                    for _i13 in range(_size9):
                        _elem14 = Json()
                        _elem14.read(iprot)
                        self.array_value.append(_elem14)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.MAP:
                    self.object_value = {}
                    (_ktype16, _vtype17, _size15) = iprot.readMapBegin()
                    for _i19 in range(_size15):
                        _key20 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val21 = Json()
                        _val21.read(iprot)
                        self.object_value[_key20] = _val21
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Json')
        if self.string_value is not None:
            oprot.writeFieldBegin('string_value', TType.STRING, 1)
            oprot.writeString(self.string_value.encode('utf-8') if sys.version_info[0] == 2 else self.string_value)
            oprot.writeFieldEnd()
        if self.int64_value is not None:
            oprot.writeFieldBegin('int64_value', TType.I64, 2)
            oprot.writeI64(self.int64_value)
            oprot.writeFieldEnd()
        if self.number_value is not None:
            oprot.writeFieldBegin('number_value', TType.DOUBLE, 3)
            oprot.writeDouble(self.number_value)
            oprot.writeFieldEnd()
        if self.boolean_value is not None:
            oprot.writeFieldBegin('boolean_value', TType.BOOL, 4)
            oprot.writeBool(self.boolean_value)
            oprot.writeFieldEnd()
        if self.array_value is not None:
            oprot.writeFieldBegin('array_value', TType.LIST, 5)
            oprot.writeListBegin(TType.STRUCT, len(self.array_value))
            for iter22 in self.array_value:
                iter22.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.object_value is not None:
            oprot.writeFieldBegin('object_value', TType.MAP, 6)
            oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.object_value))
            for kiter23, viter24 in self.object_value.items():
                oprot.writeString(kiter23.encode('utf-8') if sys.version_info[0] == 2 else kiter23)
                viter24.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class TabOutput(object):
    """
    Already-computed output of a tab.

    During workflow execute, the output from one tab can be used as the input to
    another. This only happens if the output was a `RenderResult` with a
    non-zero-column `table`. (The executor won't run a Step whose inputs aren't
    valid.)

    Attributes:
     - tab_name: Tab that was processed.
     - table_filename: Output from the final Step in `tab`.

    """

    __slots__ = (
        'tab_name',
        'table_filename',
    )


    def __init__(self, tab_name=None, table_filename=None,):
        self.tab_name = tab_name
        self.table_filename = table_filename

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.tab_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.table_filename = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TabOutput')
        if self.tab_name is not None:
            oprot.writeFieldBegin('tab_name', TType.STRING, 1)
            oprot.writeString(self.tab_name.encode('utf-8') if sys.version_info[0] == 2 else self.tab_name)
            oprot.writeFieldEnd()
        if self.table_filename is not None:
            oprot.writeFieldBegin('table_filename', TType.STRING, 2)
            oprot.writeString(self.table_filename.encode('utf-8') if sys.version_info[0] == 2 else self.table_filename)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class I18nArgument(object):
    """
    Argument to a translatable string.

    Attributes:
     - string_value
     - i32_value
     - double_value

    """

    __slots__ = (
        'string_value',
        'i32_value',
        'double_value',
    )


    def __init__(self, string_value=None, i32_value=None, double_value=None,):
        self.string_value = string_value
        self.i32_value = i32_value
        self.double_value = double_value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.string_value = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.i32_value = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.double_value = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('I18nArgument')
        if self.string_value is not None:
            oprot.writeFieldBegin('string_value', TType.STRING, 1)
            oprot.writeString(self.string_value.encode('utf-8') if sys.version_info[0] == 2 else self.string_value)
            oprot.writeFieldEnd()
        if self.i32_value is not None:
            oprot.writeFieldBegin('i32_value', TType.I32, 2)
            oprot.writeI32(self.i32_value)
            oprot.writeFieldEnd()
        if self.double_value is not None:
            oprot.writeFieldBegin('double_value', TType.DOUBLE, 3)
            oprot.writeDouble(self.double_value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class I18nMessage(object):
    """
    Translation key and arguments.

    Attributes:
     - id: Message ID. For instance, `modules.renamecolumns.duplicateColname`
     - arguments: Arguments (if Message ID takes any).

    For instance, `{"nColumns": 3, "exampleColumn": "Column X"}`
     - source: Pointer to code repository whose catalog translates the message. "library" or "module"

    """

    __slots__ = (
        'id',
        'arguments',
        'source',
    )


    def __init__(self, id=None, arguments=None, source=None,):
        self.id = id
        self.arguments = arguments
        self.source = source

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.id = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.arguments = {}
                    (_ktype26, _vtype27, _size25) = iprot.readMapBegin()
                    for _i29 in range(_size25):
                        _key30 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val31 = I18nArgument()
                        _val31.read(iprot)
                        self.arguments[_key30] = _val31
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.source = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('I18nMessage')
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.STRING, 1)
            oprot.writeString(self.id.encode('utf-8') if sys.version_info[0] == 2 else self.id)
            oprot.writeFieldEnd()
        if self.arguments is not None:
            oprot.writeFieldBegin('arguments', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.arguments))
            for kiter32, viter33 in self.arguments.items():
                oprot.writeString(kiter32.encode('utf-8') if sys.version_info[0] == 2 else kiter32)
                viter33.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.source is not None:
            oprot.writeFieldBegin('source', TType.STRING, 3)
            oprot.writeString(self.source.encode('utf-8') if sys.version_info[0] == 2 else self.source)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class PrependStepQuickFixAction(object):
    """
    Instruction that upon clicking a button, Workbench should create a Step.

    Attributes:
     - module_slug: Module to prepend.
     - partial_params: Some params to set on the new Step (atop the module's defaults).

    """

    __slots__ = (
        'module_slug',
        'partial_params',
    )


    def __init__(self, module_slug=None, partial_params=None,):
        self.module_slug = module_slug
        self.partial_params = partial_params

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.module_slug = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.partial_params = {}
                    (_ktype35, _vtype36, _size34) = iprot.readMapBegin()
                    for _i38 in range(_size34):
                        _key39 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val40 = Json()
                        _val40.read(iprot)
                        self.partial_params[_key39] = _val40
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('PrependStepQuickFixAction')
        if self.module_slug is not None:
            oprot.writeFieldBegin('module_slug', TType.STRING, 1)
            oprot.writeString(self.module_slug.encode('utf-8') if sys.version_info[0] == 2 else self.module_slug)
            oprot.writeFieldEnd()
        if self.partial_params is not None:
            oprot.writeFieldBegin('partial_params', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.partial_params))
            for kiter41, viter42 in self.partial_params.items():
                oprot.writeString(kiter41.encode('utf-8') if sys.version_info[0] == 2 else kiter41)
                viter42.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class QuickFixAction(object):
    """
    Instruction for what happens when the user clicks a Quick Fix button.

    Attributes:
     - prepend_step: Clicking the button will add a Step before the button's Step.

    """

    __slots__ = (
        'prepend_step',
    )


    def __init__(self, prepend_step=None,):
        self.prepend_step = prepend_step

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.prepend_step = PrependStepQuickFixAction()
                    self.prepend_step.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('QuickFixAction')
        if self.prepend_step is not None:
            oprot.writeFieldBegin('prepend_step', TType.STRUCT, 1)
            self.prepend_step.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class QuickFix(object):
    """
    Button the user can click in response to an error message.

    Attributes:
     - button_text
     - action

    """

    __slots__ = (
        'button_text',
        'action',
    )


    def __init__(self, button_text=None, action=None,):
        self.button_text = button_text
        self.action = action

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.button_text = I18nMessage()
                    self.button_text.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.action = QuickFixAction()
                    self.action.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('QuickFix')
        if self.button_text is not None:
            oprot.writeFieldBegin('button_text', TType.STRUCT, 1)
            self.button_text.write(oprot)
            oprot.writeFieldEnd()
        if self.action is not None:
            oprot.writeFieldBegin('action', TType.STRUCT, 2)
            self.action.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class RenderError(object):
    """
    Error or warning encountered during `render()`.

    If `render()` output is a zero-column table, then its result's errors are
    "errors" -- they prevent the workflow from executing. If `render()` outputs
    columns, though, then its result's errors are "warnings" -- execution
    continues and these messages are presented to the user.

    Attributes:
     - message
     - quick_fixes

    """

    __slots__ = (
        'message',
        'quick_fixes',
    )


    def __init__(self, message=None, quick_fixes=None,):
        self.message = message
        self.quick_fixes = quick_fixes

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.message = I18nMessage()
                    self.message.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.quick_fixes = []
                    (_etype46, _size43) = iprot.readListBegin()
                    for _i47 in range(_size43):
                        _elem48 = QuickFix()
                        _elem48.read(iprot)
                        self.quick_fixes.append(_elem48)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RenderError')
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRUCT, 1)
            self.message.write(oprot)
            oprot.writeFieldEnd()
        if self.quick_fixes is not None:
            oprot.writeFieldBegin('quick_fixes', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.quick_fixes))
            for iter49 in self.quick_fixes:
                iter49.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class FetchRequest(object):
    """
    Parameters to `fetch()`.

    Attributes:
     - basedir: Directory where the module will be allowed to read and write.

    Filenames in the fetch request/response pairs must not contain
    subdirectories or start with dots; and they must exist within this
    directory.
     - params: User-supplied params.
     - secrets: User-supplied secrets.
     - last_fetch_result: Result of the previous fetch().

    This is to support modules that "accumulate" data. Think of their fetch()
    as a reducer: each time they run, they operate on their previous output.
    (e.g., Twitter module monitoring a politician's tweets.)

    A Step may never run two fetches concurrently.

    Empty on initial call.
     - input_table_parquet_filename: Cached result from previous module's render, if fresh.

    This is to support modules that take a column as input. Unfortunately, we
    have a lot more work to do to make these modules work as expected. (The
    changes will probably require rewriting all modules that use this
    feature.) In the meantime, this hack gets some jobs done.

    The file on disk is in the directory, `basedir`, and it is readable.
     - output_filename: File where the result should be written.

    The caller is assumed to have made a best effort to ensure the file is
    writable.

    The file on disk is in the directory, `basedir`, and it is writable.

    """

    __slots__ = (
        'basedir',
        'params',
        'secrets',
        'last_fetch_result',
        'input_table_parquet_filename',
        'output_filename',
    )


    def __init__(self, basedir=None, params=None, secrets=None, last_fetch_result=None, input_table_parquet_filename=None, output_filename=None,):
        self.basedir = basedir
        self.params = params
        self.secrets = secrets
        self.last_fetch_result = last_fetch_result
        self.input_table_parquet_filename = input_table_parquet_filename
        self.output_filename = output_filename

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.basedir = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.params = {}
                    (_ktype51, _vtype52, _size50) = iprot.readMapBegin()
                    for _i54 in range(_size50):
                        _key55 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val56 = Json()
                        _val56.read(iprot)
                        self.params[_key55] = _val56
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.MAP:
                    self.secrets = {}
                    (_ktype58, _vtype59, _size57) = iprot.readMapBegin()
                    for _i61 in range(_size57):
                        _key62 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val63 = Json()
                        _val63.read(iprot)
                        self.secrets[_key62] = _val63
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.last_fetch_result = FetchResult()
                    self.last_fetch_result.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.input_table_parquet_filename = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.output_filename = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('FetchRequest')
        if self.basedir is not None:
            oprot.writeFieldBegin('basedir', TType.STRING, 1)
            oprot.writeString(self.basedir.encode('utf-8') if sys.version_info[0] == 2 else self.basedir)
            oprot.writeFieldEnd()
        if self.params is not None:
            oprot.writeFieldBegin('params', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.params))
            for kiter64, viter65 in self.params.items():
                oprot.writeString(kiter64.encode('utf-8') if sys.version_info[0] == 2 else kiter64)
                viter65.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.secrets is not None:
            oprot.writeFieldBegin('secrets', TType.MAP, 3)
            oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.secrets))
            for kiter66, viter67 in self.secrets.items():
                oprot.writeString(kiter66.encode('utf-8') if sys.version_info[0] == 2 else kiter66)
                viter67.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.last_fetch_result is not None:
            oprot.writeFieldBegin('last_fetch_result', TType.STRUCT, 4)
            self.last_fetch_result.write(oprot)
            oprot.writeFieldEnd()
        if self.input_table_parquet_filename is not None:
            oprot.writeFieldBegin('input_table_parquet_filename', TType.STRING, 5)
            oprot.writeString(self.input_table_parquet_filename.encode('utf-8') if sys.version_info[0] == 2 else self.input_table_parquet_filename)
            oprot.writeFieldEnd()
        if self.output_filename is not None:
            oprot.writeFieldBegin('output_filename', TType.STRING, 6)
            oprot.writeString(self.output_filename.encode('utf-8') if sys.version_info[0] == 2 else self.output_filename)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class FetchResult(object):
    """
    The module executed a Step's fetch() without crashing.

    An "ok" result may be a user-friendly error -- that is, an empty file (or,
    for backwards compat, a zero-column parquet file) and non-empty `errors`.

    The module writes the output data to `fetch_request.output_file`.

    Empty file or zero-column parquet file typically means, "error"; but
    that's the module's choice and not a hard-and-fast rule.

    Attributes:
     - filename
     - errors: User-facing errors or warnings reported by the module.

    These are separate from `filename` for two reasons: 1) a convenience for
    module authors; and 2) so we can run SQL to find common problems.

    """

    __slots__ = (
        'filename',
        'errors',
    )


    def __init__(self, filename=None, errors=None,):
        self.filename = filename
        self.errors = errors

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.filename = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.errors = []
                    (_etype71, _size68) = iprot.readListBegin()
                    for _i72 in range(_size68):
                        _elem73 = RenderError()
                        _elem73.read(iprot)
                        self.errors.append(_elem73)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('FetchResult')
        if self.filename is not None:
            oprot.writeFieldBegin('filename', TType.STRING, 1)
            oprot.writeString(self.filename.encode('utf-8') if sys.version_info[0] == 2 else self.filename)
            oprot.writeFieldEnd()
        if self.errors is not None:
            oprot.writeFieldBegin('errors', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.errors))
            for iter74 in self.errors:
                iter74.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class UploadedFile(object):
    """
    File the user uploaded.

    This points to a file on disk. The file on disk has the same extension as the
    original filename.

    Attributes:
     - name: Filename the user uploaded.
     - filename: Filename on disk.
     - uploaded_at_timestampus: Time the file was uploaded, in microseconds since the epoch.

    """

    __slots__ = (
        'name',
        'filename',
        'uploaded_at_timestampus',
    )


    def __init__(self, name=None, filename=None, uploaded_at_timestampus=None,):
        self.name = name
        self.filename = filename
        self.uploaded_at_timestampus = uploaded_at_timestampus

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.filename = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.uploaded_at_timestampus = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('UploadedFile')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.filename is not None:
            oprot.writeFieldBegin('filename', TType.STRING, 2)
            oprot.writeString(self.filename.encode('utf-8') if sys.version_info[0] == 2 else self.filename)
            oprot.writeFieldEnd()
        if self.uploaded_at_timestampus is not None:
            oprot.writeFieldBegin('uploaded_at_timestampus', TType.I64, 3)
            oprot.writeI64(self.uploaded_at_timestampus)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class RenderRequest(object):
    """
    Parameters to `render()`.

    Attributes:
     - basedir: Directory on disk where all filenames in this request are to be found.

    The RenderResponse file is expected to be written here, too.

    Here's a way to safely reuse this directory after every render(): when
    sandboxing, mount an OverlayFS with all the input files as read-only,
    then overlay-mount a "scratch" directory for the module to use (and
    write to `output_filename`).
     - input_filename: Output from previous Step.

    This is zero-row, zero-column on the first Step in a Tab.
     - params: User-supplied parameters; must match the module's param_schema.

    `File` params are passed as strings, pointing to temporary files in
    `basedir`.
     - tab_name: Description of tab being rendered.
     - fetch_result: Result of latest `fetch`.

    If unset, `fetch` was never called.

    `fetch_result.filename` will point to a temporary file in `basedir`.
     - output_filename: File where the result Arrow table should be written.

    The caller is assumed to have made a best effort to ensure the file is
    writable.

    The file on disk will be in `basedir`.
     - tab_outputs: Outputs from other tabs that are inputs into this Step, keyed by slug.

    `params` values may refer to keys here.
     - uploaded_files: Files the user uploaded and chose, keyed by UUID.

    `params` values may refer to keys here.

    """

    __slots__ = (
        'basedir',
        'input_filename',
        'params',
        'tab_name',
        'fetch_result',
        'output_filename',
        'tab_outputs',
        'uploaded_files',
    )


    def __init__(self, basedir=None, input_filename=None, params=None, tab_name=None, fetch_result=None, output_filename=None, tab_outputs=None, uploaded_files=None,):
        self.basedir = basedir
        self.input_filename = input_filename
        self.params = params
        self.tab_name = tab_name
        self.fetch_result = fetch_result
        self.output_filename = output_filename
        self.tab_outputs = tab_outputs
        self.uploaded_files = uploaded_files

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.basedir = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.input_filename = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.MAP:
                    self.params = {}
                    (_ktype76, _vtype77, _size75) = iprot.readMapBegin()
                    for _i79 in range(_size75):
                        _key80 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val81 = Json()
                        _val81.read(iprot)
                        self.params[_key80] = _val81
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.tab_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.fetch_result = FetchResult()
                    self.fetch_result.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.output_filename = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.MAP:
                    self.tab_outputs = {}
                    (_ktype83, _vtype84, _size82) = iprot.readMapBegin()
                    for _i86 in range(_size82):
                        _key87 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val88 = TabOutput()
                        _val88.read(iprot)
                        self.tab_outputs[_key87] = _val88
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.MAP:
                    self.uploaded_files = {}
                    (_ktype90, _vtype91, _size89) = iprot.readMapBegin()
                    for _i93 in range(_size89):
                        _key94 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val95 = UploadedFile()
                        _val95.read(iprot)
                        self.uploaded_files[_key94] = _val95
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RenderRequest')
        if self.basedir is not None:
            oprot.writeFieldBegin('basedir', TType.STRING, 1)
            oprot.writeString(self.basedir.encode('utf-8') if sys.version_info[0] == 2 else self.basedir)
            oprot.writeFieldEnd()
        if self.input_filename is not None:
            oprot.writeFieldBegin('input_filename', TType.STRING, 2)
            oprot.writeString(self.input_filename.encode('utf-8') if sys.version_info[0] == 2 else self.input_filename)
            oprot.writeFieldEnd()
        if self.params is not None:
            oprot.writeFieldBegin('params', TType.MAP, 3)
            oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.params))
            for kiter96, viter97 in self.params.items():
                oprot.writeString(kiter96.encode('utf-8') if sys.version_info[0] == 2 else kiter96)
                viter97.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.tab_name is not None:
            oprot.writeFieldBegin('tab_name', TType.STRING, 4)
            oprot.writeString(self.tab_name.encode('utf-8') if sys.version_info[0] == 2 else self.tab_name)
            oprot.writeFieldEnd()
        if self.fetch_result is not None:
            oprot.writeFieldBegin('fetch_result', TType.STRUCT, 5)
            self.fetch_result.write(oprot)
            oprot.writeFieldEnd()
        if self.output_filename is not None:
            oprot.writeFieldBegin('output_filename', TType.STRING, 6)
            oprot.writeString(self.output_filename.encode('utf-8') if sys.version_info[0] == 2 else self.output_filename)
            oprot.writeFieldEnd()
        if self.tab_outputs is not None:
            oprot.writeFieldBegin('tab_outputs', TType.MAP, 7)
            oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.tab_outputs))
            for kiter98, viter99 in self.tab_outputs.items():
                oprot.writeString(kiter98.encode('utf-8') if sys.version_info[0] == 2 else kiter98)
                viter99.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.uploaded_files is not None:
            oprot.writeFieldBegin('uploaded_files', TType.MAP, 8)
            oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.uploaded_files))
            for kiter100, viter101 in self.uploaded_files.items():
                oprot.writeString(kiter100.encode('utf-8') if sys.version_info[0] == 2 else kiter100)
                viter101.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class RenderResult(object):
    """
    The module executed a Step's render() without crashing.

    An "ok" result may be a user-friendly error -- that is, a zero-column table
    and non-empty `errors`.

    The module writes the output Arrow data to `render_request.output_file`.

    Attributes:
     - errors: User-facing errors or warnings reported by the module.
     - json: JSON to pass to the module's HTML, if it has HTML.

    """

    __slots__ = (
        'errors',
        'json',
    )


    def __init__(self, errors=None, json=None,):
        self.errors = errors
        self.json = json

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.errors = []
                    (_etype105, _size102) = iprot.readListBegin()
                    for _i106 in range(_size102):
                        _elem107 = RenderError()
                        _elem107.read(iprot)
                        self.errors.append(_elem107)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.json = {}
                    (_ktype109, _vtype110, _size108) = iprot.readMapBegin()
                    for _i112 in range(_size108):
                        _key113 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val114 = Json()
                        _val114.read(iprot)
                        self.json[_key113] = _val114
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RenderResult')
        if self.errors is not None:
            oprot.writeFieldBegin('errors', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.errors))
            for iter115 in self.errors:
                iter115.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.json is not None:
            oprot.writeFieldBegin('json', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.json))
            for kiter116, viter117 in self.json.items():
                oprot.writeString(kiter116.encode('utf-8') if sys.version_info[0] == 2 else kiter116)
                viter117.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(ValidateModuleResult)
ValidateModuleResult.thrift_spec = (
)
all_structs.append(MigrateParamsResult)
MigrateParamsResult.thrift_spec = (
    None,  # 0
    (1, TType.MAP, 'params', (TType.STRING, 'UTF8', TType.STRUCT, [Json, None], False), None, ),  # 1
)
all_structs.append(Json)
Json.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'string_value', 'UTF8', None, ),  # 1
    (2, TType.I64, 'int64_value', None, None, ),  # 2
    (3, TType.DOUBLE, 'number_value', None, None, ),  # 3
    (4, TType.BOOL, 'boolean_value', None, None, ),  # 4
    (5, TType.LIST, 'array_value', (TType.STRUCT, [Json, None], False), None, ),  # 5
    (6, TType.MAP, 'object_value', (TType.STRING, 'UTF8', TType.STRUCT, [Json, None], False), None, ),  # 6
)
all_structs.append(TabOutput)
TabOutput.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'tab_name', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'table_filename', 'UTF8', None, ),  # 2
)
all_structs.append(I18nArgument)
I18nArgument.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'string_value', 'UTF8', None, ),  # 1
    (2, TType.I32, 'i32_value', None, None, ),  # 2
    (3, TType.DOUBLE, 'double_value', None, None, ),  # 3
)
all_structs.append(I18nMessage)
I18nMessage.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'id', 'UTF8', None, ),  # 1
    (2, TType.MAP, 'arguments', (TType.STRING, 'UTF8', TType.STRUCT, [I18nArgument, None], False), None, ),  # 2
    (3, TType.STRING, 'source', 'UTF8', None, ),  # 3
)
all_structs.append(PrependStepQuickFixAction)
PrependStepQuickFixAction.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'module_slug', 'UTF8', None, ),  # 1
    (2, TType.MAP, 'partial_params', (TType.STRING, 'UTF8', TType.STRUCT, [Json, None], False), None, ),  # 2
)
all_structs.append(QuickFixAction)
QuickFixAction.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'prepend_step', [PrependStepQuickFixAction, None], None, ),  # 1
)
all_structs.append(QuickFix)
QuickFix.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'button_text', [I18nMessage, None], None, ),  # 1
    (2, TType.STRUCT, 'action', [QuickFixAction, None], None, ),  # 2
)
all_structs.append(RenderError)
RenderError.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'message', [I18nMessage, None], None, ),  # 1
    (2, TType.LIST, 'quick_fixes', (TType.STRUCT, [QuickFix, None], False), None, ),  # 2
)
all_structs.append(FetchRequest)
FetchRequest.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'basedir', 'UTF8', None, ),  # 1
    (2, TType.MAP, 'params', (TType.STRING, 'UTF8', TType.STRUCT, [Json, None], False), None, ),  # 2
    (3, TType.MAP, 'secrets', (TType.STRING, 'UTF8', TType.STRUCT, [Json, None], False), None, ),  # 3
    (4, TType.STRUCT, 'last_fetch_result', [FetchResult, None], None, ),  # 4
    (5, TType.STRING, 'input_table_parquet_filename', 'UTF8', None, ),  # 5
    (6, TType.STRING, 'output_filename', 'UTF8', None, ),  # 6
)
all_structs.append(FetchResult)
FetchResult.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'filename', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'errors', (TType.STRUCT, [RenderError, None], False), None, ),  # 2
)
all_structs.append(UploadedFile)
UploadedFile.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'filename', 'UTF8', None, ),  # 2
    (3, TType.I64, 'uploaded_at_timestampus', None, None, ),  # 3
)
all_structs.append(RenderRequest)
RenderRequest.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'basedir', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'input_filename', 'UTF8', None, ),  # 2
    (3, TType.MAP, 'params', (TType.STRING, 'UTF8', TType.STRUCT, [Json, None], False), None, ),  # 3
    (4, TType.STRING, 'tab_name', 'UTF8', None, ),  # 4
    (5, TType.STRUCT, 'fetch_result', [FetchResult, None], None, ),  # 5
    (6, TType.STRING, 'output_filename', 'UTF8', None, ),  # 6
    (7, TType.MAP, 'tab_outputs', (TType.STRING, 'UTF8', TType.STRUCT, [TabOutput, None], False), None, ),  # 7
    (8, TType.MAP, 'uploaded_files', (TType.STRING, 'UTF8', TType.STRUCT, [UploadedFile, None], False), None, ),  # 8
)
all_structs.append(RenderResult)
RenderResult.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'errors', (TType.STRUCT, [RenderError, None], False), None, ),  # 1
    (2, TType.MAP, 'json', (TType.STRING, 'UTF8', TType.STRUCT, [Json, None], False), None, ),  # 2
)
fix_spec(all_structs)
del all_structs
