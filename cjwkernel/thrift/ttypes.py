#
# Autogenerated by Thrift Compiler (0.13.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:slots
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys

from thrift.transport import TTransport
all_structs = []


class ValidateModuleResult(object):
    """
    Validation of a kernel module's code succeeded.

    This value cannot be trusted: a malicious module may report that it is ok.
    (Indeed, many buggy modules _will_ self-report as ok.)

    """

    __slots__ = (
    )


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ValidateModuleResult')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class ColumnTypeText(object):
    """
    A "text"-typed column.

    """

    __slots__ = (
    )


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ColumnTypeText')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class ColumnTypeNumber(object):
    """
    A "number"-typed column.

    Attributes:
     - format: Python-syntax number format, like `{,.2%}`

    """

    __slots__ = (
        'format',
    )


    def __init__(self, format="{:,}",):
        self.format = format

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.format = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ColumnTypeNumber')
        if self.format is not None:
            oprot.writeFieldBegin('format', TType.STRING, 1)
            oprot.writeString(self.format.encode('utf-8') if sys.version_info[0] == 2 else self.format)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class ColumnTypeDatetime(object):
    """
    A "datetime"-typed column.

    """

    __slots__ = (
    )


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ColumnTypeDatetime')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class ColumnType(object):
    """
    The type (and its options) of a column.

    This is the _user-visible_ type. We do not store the bit layout. For
    instance, we store "number" and not "i32" or "i64".

    Attributes:
     - text_type
     - number_type
     - datetime_type

    """

    __slots__ = (
        'text_type',
        'number_type',
        'datetime_type',
    )


    def __init__(self, text_type=None, number_type=None, datetime_type=None,):
        self.text_type = text_type
        self.number_type = number_type
        self.datetime_type = datetime_type

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.text_type = ColumnTypeText()
                    self.text_type.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.number_type = ColumnTypeNumber()
                    self.number_type.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.datetime_type = ColumnTypeDatetime()
                    self.datetime_type.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ColumnType')
        if self.text_type is not None:
            oprot.writeFieldBegin('text_type', TType.STRUCT, 1)
            self.text_type.write(oprot)
            oprot.writeFieldEnd()
        if self.number_type is not None:
            oprot.writeFieldBegin('number_type', TType.STRUCT, 2)
            self.number_type.write(oprot)
            oprot.writeFieldEnd()
        if self.datetime_type is not None:
            oprot.writeFieldBegin('datetime_type', TType.STRUCT, 3)
            self.datetime_type.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class Column(object):
    """
    Description of a column in a table.

    Attributes:
     - name: Name of the column (unique among all columns in the table).
     - type: Date type the user will see.

    """

    __slots__ = (
        'name',
        'type',
    )


    def __init__(self, name=None, type=None,):
        self.name = name
        self.type = type

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.type = ColumnType()
                    self.type.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Column')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.STRUCT, 2)
            self.type.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class TableMetadata(object):
    """
    Table data that will be cached for easy access.

    Attributes:
     - n_rows: Number of rows in the table.
     - columns: Columns -- the user-visible aspects of them, at least.

    """

    __slots__ = (
        'n_rows',
        'columns',
    )


    def __init__(self, n_rows=None, columns=None,):
        self.n_rows = n_rows
        self.columns = columns

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.n_rows = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.columns = []
                    (_etype3, _size0) = iprot.readListBegin()
                    for _i4 in range(_size0):
                        _elem5 = Column()
                        _elem5.read(iprot)
                        self.columns.append(_elem5)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TableMetadata')
        if self.n_rows is not None:
            oprot.writeFieldBegin('n_rows', TType.I32, 1)
            oprot.writeI32(self.n_rows)
            oprot.writeFieldEnd()
        if self.columns is not None:
            oprot.writeFieldBegin('columns', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.columns))
            for iter6 in self.columns:
                iter6.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class ArrowTable(object):
    """
    Table stored on disk, ready to be mmapped.

    Attributes:
     - filename: Name of file on disk that contains data.

    For a zero-column table, filename may be the empty string -- meaning there
    is no file on disk. In all other cases, the file on disk must exist.

    The file on disk is in a directory agreed upon by the processes passing
    this data around. Subdirectories and hidden files aren't allowed.
     - metadata: Metadata; must agree with the file on disk.

    """

    __slots__ = (
        'filename',
        'metadata',
    )


    def __init__(self, filename=None, metadata=None,):
        self.filename = filename
        self.metadata = metadata

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.filename = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.metadata = TableMetadata()
                    self.metadata.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ArrowTable')
        if self.filename is not None:
            oprot.writeFieldBegin('filename', TType.STRING, 1)
            oprot.writeString(self.filename.encode('utf-8') if sys.version_info[0] == 2 else self.filename)
            oprot.writeFieldEnd()
        if self.metadata is not None:
            oprot.writeFieldBegin('metadata', TType.STRUCT, 2)
            self.metadata.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class ParamValue(object):
    """
    Value (or nested value) in Params passed to render()/fetch().

    These params are connected to the `table` parameter: a "column"-typed
    parameter will be a `Column`; a "tab"-typed parameter will be a `TabOutput`.

    This is more permissive than module_spec. Callers should validate against
    the module spec.

    The special value `None` is allowed. Thrift unions are just structs with
    optional fields; in this case, if all fields are unset, then that means
    `null`.

    Attributes:
     - string_value: String value.

    This represents "string", "enum" and "file" values. Over the wire, it's
    all the same to us.
     - integer_value
     - float_value
     - boolean_value
     - column_value
     - tab_value
     - list_value: List of nested values.

    This represents "list", "multicolumn", "multitab" and "multichartseries"
    dtypes. Over the wire, it's all the same to us.
     - map_value: Mapping of key to nested value.

    This represents "map" and "dict" dtypes. Over the wire, it's all the same
    to us.
     - filename_value: A string filename, with no path information, pointing to a file on disk.

    The directory is assumed based on context.

    """

    __slots__ = (
        'string_value',
        'integer_value',
        'float_value',
        'boolean_value',
        'column_value',
        'tab_value',
        'list_value',
        'map_value',
        'filename_value',
    )


    def __init__(self, string_value=None, integer_value=None, float_value=None, boolean_value=None, column_value=None, tab_value=None, list_value=None, map_value=None, filename_value=None,):
        self.string_value = string_value
        self.integer_value = integer_value
        self.float_value = float_value
        self.boolean_value = boolean_value
        self.column_value = column_value
        self.tab_value = tab_value
        self.list_value = list_value
        self.map_value = map_value
        self.filename_value = filename_value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.string_value = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.integer_value = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.float_value = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.boolean_value = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.column_value = Column()
                    self.column_value.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.tab_value = TabOutput()
                    self.tab_value.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.LIST:
                    self.list_value = []
                    (_etype10, _size7) = iprot.readListBegin()
                    for _i11 in range(_size7):
                        _elem12 = ParamValue()
                        _elem12.read(iprot)
                        self.list_value.append(_elem12)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.MAP:
                    self.map_value = {}
                    (_ktype14, _vtype15, _size13) = iprot.readMapBegin()
                    for _i17 in range(_size13):
                        _key18 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val19 = ParamValue()
                        _val19.read(iprot)
                        self.map_value[_key18] = _val19
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRING:
                    self.filename_value = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ParamValue')
        if self.string_value is not None:
            oprot.writeFieldBegin('string_value', TType.STRING, 1)
            oprot.writeString(self.string_value.encode('utf-8') if sys.version_info[0] == 2 else self.string_value)
            oprot.writeFieldEnd()
        if self.integer_value is not None:
            oprot.writeFieldBegin('integer_value', TType.I64, 2)
            oprot.writeI64(self.integer_value)
            oprot.writeFieldEnd()
        if self.float_value is not None:
            oprot.writeFieldBegin('float_value', TType.DOUBLE, 3)
            oprot.writeDouble(self.float_value)
            oprot.writeFieldEnd()
        if self.boolean_value is not None:
            oprot.writeFieldBegin('boolean_value', TType.BOOL, 4)
            oprot.writeBool(self.boolean_value)
            oprot.writeFieldEnd()
        if self.column_value is not None:
            oprot.writeFieldBegin('column_value', TType.STRUCT, 5)
            self.column_value.write(oprot)
            oprot.writeFieldEnd()
        if self.tab_value is not None:
            oprot.writeFieldBegin('tab_value', TType.STRUCT, 6)
            self.tab_value.write(oprot)
            oprot.writeFieldEnd()
        if self.list_value is not None:
            oprot.writeFieldBegin('list_value', TType.LIST, 7)
            oprot.writeListBegin(TType.STRUCT, len(self.list_value))
            for iter20 in self.list_value:
                iter20.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.map_value is not None:
            oprot.writeFieldBegin('map_value', TType.MAP, 8)
            oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.map_value))
            for kiter21, viter22 in self.map_value.items():
                oprot.writeString(kiter21.encode('utf-8') if sys.version_info[0] == 2 else kiter21)
                viter22.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.filename_value is not None:
            oprot.writeFieldBegin('filename_value', TType.STRING, 9)
            oprot.writeString(self.filename_value.encode('utf-8') if sys.version_info[0] == 2 else self.filename_value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class RawParams(object):
    """
    Value (or nested value) passed to `migrate_params()`.

    Raw parameter values are stored in the database as JSON. We pass them using
    JSON-encoded string. This is not the same as the Thrift type "Params", which
    is passed to `render()`: Params are objects with TabOutput/Column/etc
    members.

    Attributes:
     - json

    """

    __slots__ = (
        'json',
    )


    def __init__(self, json=None,):
        self.json = json

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.json = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RawParams')
        if self.json is not None:
            oprot.writeFieldBegin('json', TType.STRING, 1)
            oprot.writeString(self.json.encode('utf-8') if sys.version_info[0] == 2 else self.json)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class Tab(object):
    """
    Tab description.

    Attributes:
     - slug: Tab identifier, unique in its Workflow.
     - name: Tab name, provided by the user.

    """

    __slots__ = (
        'slug',
        'name',
    )


    def __init__(self, slug=None, name=None,):
        self.slug = slug
        self.name = name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.slug = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Tab')
        if self.slug is not None:
            oprot.writeFieldBegin('slug', TType.STRING, 1)
            oprot.writeString(self.slug.encode('utf-8') if sys.version_info[0] == 2 else self.slug)
            oprot.writeFieldEnd()
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 2)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class TabOutput(object):
    """
    Already-computed output of a tab.

    During workflow execute, the output from one tab can be used as the input to
    another. This only happens if the output was a `RenderResult` with a
    non-zero-column `table`. (The executor won't run a Step whose inputs aren't
    valid.)

    Attributes:
     - tab: Tab that was processed.
     - table: Output from the final Step in `tab`.

    """

    __slots__ = (
        'tab',
        'table',
    )


    def __init__(self, tab=None, table=None,):
        self.tab = tab
        self.table = table

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.tab = Tab()
                    self.tab.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.table = ArrowTable()
                    self.table.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TabOutput')
        if self.tab is not None:
            oprot.writeFieldBegin('tab', TType.STRUCT, 1)
            self.tab.write(oprot)
            oprot.writeFieldEnd()
        if self.table is not None:
            oprot.writeFieldBegin('table', TType.STRUCT, 2)
            self.table.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class I18nArgument(object):
    """
    Argument to a translatable string.

    Attributes:
     - string_value
     - i32_value
     - double_value

    """

    __slots__ = (
        'string_value',
        'i32_value',
        'double_value',
    )


    def __init__(self, string_value=None, i32_value=None, double_value=None,):
        self.string_value = string_value
        self.i32_value = i32_value
        self.double_value = double_value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.string_value = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.i32_value = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.double_value = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('I18nArgument')
        if self.string_value is not None:
            oprot.writeFieldBegin('string_value', TType.STRING, 1)
            oprot.writeString(self.string_value.encode('utf-8') if sys.version_info[0] == 2 else self.string_value)
            oprot.writeFieldEnd()
        if self.i32_value is not None:
            oprot.writeFieldBegin('i32_value', TType.I32, 2)
            oprot.writeI32(self.i32_value)
            oprot.writeFieldEnd()
        if self.double_value is not None:
            oprot.writeFieldBegin('double_value', TType.DOUBLE, 3)
            oprot.writeDouble(self.double_value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class I18nMessageSource(object):
    """
    Source of a translatable string.
    If none of the values are set, this means it's coming from workbench itself

    Attributes:
     - library: If `"library"` is set, this means it's coming from some of our supported libraries
     - module_id: If `"module_id"` is set, this means it's coming from a module
    `"module"` is reserved in thrift, that's why we added a `"_"`

    """

    __slots__ = (
        'library',
        'module_id',
    )


    def __init__(self, library=None, module_id=None,):
        self.library = library
        self.module_id = module_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.library = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.module_id = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('I18nMessageSource')
        if self.library is not None:
            oprot.writeFieldBegin('library', TType.STRING, 1)
            oprot.writeString(self.library.encode('utf-8') if sys.version_info[0] == 2 else self.library)
            oprot.writeFieldEnd()
        if self.module_id is not None:
            oprot.writeFieldBegin('module_id', TType.STRING, 2)
            oprot.writeString(self.module_id.encode('utf-8') if sys.version_info[0] == 2 else self.module_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class I18nMessage(object):
    """
    Translation key and arguments.

    Attributes:
     - id: Message ID. For instance, `modules.renamecolumns.duplicateColname`
     - arguments: Arguments (if Message ID takes any).

    For instance, `{"nColumns": 3, "exampleColumn": "Column X"}`
     - source: An indication of where the message is coming from.

    """

    __slots__ = (
        'id',
        'arguments',
        'source',
    )


    def __init__(self, id=None, arguments=None, source=None,):
        self.id = id
        self.arguments = arguments
        self.source = source

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.id = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.arguments = {}
                    (_ktype24, _vtype25, _size23) = iprot.readMapBegin()
                    for _i27 in range(_size23):
                        _key28 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val29 = I18nArgument()
                        _val29.read(iprot)
                        self.arguments[_key28] = _val29
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.source = I18nMessageSource()
                    self.source.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('I18nMessage')
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.STRING, 1)
            oprot.writeString(self.id.encode('utf-8') if sys.version_info[0] == 2 else self.id)
            oprot.writeFieldEnd()
        if self.arguments is not None:
            oprot.writeFieldBegin('arguments', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.arguments))
            for kiter30, viter31 in self.arguments.items():
                oprot.writeString(kiter30.encode('utf-8') if sys.version_info[0] == 2 else kiter30)
                viter31.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.source is not None:
            oprot.writeFieldBegin('source', TType.STRUCT, 3)
            self.source.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class PrependStepQuickFixAction(object):
    """
    Instruction that upon clicking a button, Workbench should create a Step.

    Attributes:
     - module_slug: Module to prepend.
     - partial_params: Some params to set on the new Step (atop the module's defaults).

    """

    __slots__ = (
        'module_slug',
        'partial_params',
    )


    def __init__(self, module_slug=None, partial_params=None,):
        self.module_slug = module_slug
        self.partial_params = partial_params

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.module_slug = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.partial_params = RawParams()
                    self.partial_params.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('PrependStepQuickFixAction')
        if self.module_slug is not None:
            oprot.writeFieldBegin('module_slug', TType.STRING, 1)
            oprot.writeString(self.module_slug.encode('utf-8') if sys.version_info[0] == 2 else self.module_slug)
            oprot.writeFieldEnd()
        if self.partial_params is not None:
            oprot.writeFieldBegin('partial_params', TType.STRUCT, 2)
            self.partial_params.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class QuickFixAction(object):
    """
    Instruction for what happens when the user clicks a Quick Fix button.

    Attributes:
     - prepend_step: Clicking the button will add a Step before the button's Step.

    """

    __slots__ = (
        'prepend_step',
    )


    def __init__(self, prepend_step=None,):
        self.prepend_step = prepend_step

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.prepend_step = PrependStepQuickFixAction()
                    self.prepend_step.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('QuickFixAction')
        if self.prepend_step is not None:
            oprot.writeFieldBegin('prepend_step', TType.STRUCT, 1)
            self.prepend_step.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class QuickFix(object):
    """
    Button the user can click in response to an error message.

    Attributes:
     - button_text
     - action

    """

    __slots__ = (
        'button_text',
        'action',
    )


    def __init__(self, button_text=None, action=None,):
        self.button_text = button_text
        self.action = action

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.button_text = I18nMessage()
                    self.button_text.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.action = QuickFixAction()
                    self.action.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('QuickFix')
        if self.button_text is not None:
            oprot.writeFieldBegin('button_text', TType.STRUCT, 1)
            self.button_text.write(oprot)
            oprot.writeFieldEnd()
        if self.action is not None:
            oprot.writeFieldBegin('action', TType.STRUCT, 2)
            self.action.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class RenderError(object):
    """
    Error or warning encountered during `render()`.

    If `render()` output is a zero-column table, then its result's errors are
    "errors" -- they prevent the workflow from executing. If `render()` outputs
    columns, though, then its result's errors are "warnings" -- execution
    continues and these messages are presented to the user.

    Attributes:
     - message
     - quick_fixes

    """

    __slots__ = (
        'message',
        'quick_fixes',
    )


    def __init__(self, message=None, quick_fixes=None,):
        self.message = message
        self.quick_fixes = quick_fixes

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.message = I18nMessage()
                    self.message.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.quick_fixes = []
                    (_etype35, _size32) = iprot.readListBegin()
                    for _i36 in range(_size32):
                        _elem37 = QuickFix()
                        _elem37.read(iprot)
                        self.quick_fixes.append(_elem37)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RenderError')
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRUCT, 1)
            self.message.write(oprot)
            oprot.writeFieldEnd()
        if self.quick_fixes is not None:
            oprot.writeFieldBegin('quick_fixes', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.quick_fixes))
            for iter38 in self.quick_fixes:
                iter38.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class FetchRequest(object):
    """
    Parameters to `fetch()`.

    Attributes:
     - basedir: Directory where the module will be allowed to read and write.

    Filenames in the fetch request/response pairs must not contain
    subdirectories or start with dots; and they must exist within this
    directory.
     - params: User-supplied params.
     - secrets: User-supplied secrets.
     - last_fetch_result: Result of the previous fetch().

    This is to support modules that "accumulate" data. Think of their fetch()
    as a reducer: each time they run, they operate on their previous output.
    (e.g., Twitter module monitoring a politician's tweets.)

    A Step may never run two fetches concurrently.

    Empty on initial call.
     - input_table_parquet_filename: Cached result from previous module's render, if fresh.

    This is to support modules that take a column as input. Unfortunately, we
    have a lot more work to do to make these modules work as expected. (The
    changes will probably require rewriting all modules that use this
    feature.) In the meantime, this hack gets some jobs done.

    The file on disk is in the directory, `basedir`, and it is readable.
     - output_filename: File where the result should be written.

    The caller is assumed to have made a best effort to ensure the file is
    writable.

    The file on disk is in the directory, `basedir`, and it is writable.

    """

    __slots__ = (
        'basedir',
        'params',
        'secrets',
        'last_fetch_result',
        'input_table_parquet_filename',
        'output_filename',
    )


    def __init__(self, basedir=None, params=None, secrets=None, last_fetch_result=None, input_table_parquet_filename=None, output_filename=None,):
        self.basedir = basedir
        self.params = params
        self.secrets = secrets
        self.last_fetch_result = last_fetch_result
        self.input_table_parquet_filename = input_table_parquet_filename
        self.output_filename = output_filename

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.basedir = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.params = {}
                    (_ktype40, _vtype41, _size39) = iprot.readMapBegin()
                    for _i43 in range(_size39):
                        _key44 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val45 = ParamValue()
                        _val45.read(iprot)
                        self.params[_key44] = _val45
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.secrets = RawParams()
                    self.secrets.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.last_fetch_result = FetchResult()
                    self.last_fetch_result.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.input_table_parquet_filename = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.output_filename = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('FetchRequest')
        if self.basedir is not None:
            oprot.writeFieldBegin('basedir', TType.STRING, 1)
            oprot.writeString(self.basedir.encode('utf-8') if sys.version_info[0] == 2 else self.basedir)
            oprot.writeFieldEnd()
        if self.params is not None:
            oprot.writeFieldBegin('params', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.params))
            for kiter46, viter47 in self.params.items():
                oprot.writeString(kiter46.encode('utf-8') if sys.version_info[0] == 2 else kiter46)
                viter47.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.secrets is not None:
            oprot.writeFieldBegin('secrets', TType.STRUCT, 3)
            self.secrets.write(oprot)
            oprot.writeFieldEnd()
        if self.last_fetch_result is not None:
            oprot.writeFieldBegin('last_fetch_result', TType.STRUCT, 4)
            self.last_fetch_result.write(oprot)
            oprot.writeFieldEnd()
        if self.input_table_parquet_filename is not None:
            oprot.writeFieldBegin('input_table_parquet_filename', TType.STRING, 5)
            oprot.writeString(self.input_table_parquet_filename.encode('utf-8') if sys.version_info[0] == 2 else self.input_table_parquet_filename)
            oprot.writeFieldEnd()
        if self.output_filename is not None:
            oprot.writeFieldBegin('output_filename', TType.STRING, 6)
            oprot.writeString(self.output_filename.encode('utf-8') if sys.version_info[0] == 2 else self.output_filename)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class FetchResult(object):
    """
    The module executed a Step's fetch() without crashing.

    An "ok" result may be a user-friendly error -- that is, an empty file (or,
    for backwards compat, a zero-column parquet file) and non-empty `errors`.

    Attributes:
     - filename: File the fetch produced.

    The kernel writes the output data to `fetch_request.output_file`.

    Currently, this must be a valid Parquet file. In the future, we will
    loosen the requirement and allow any file.

    Empty file or zero-column parquet file typically means, "error"; but
    that's the module's choice and not a hard-and-fast rule.

    The file on disk is in a directory agreed upon by the processes passing
    this data around. Subdirectories and hidden files aren't allowed.
     - errors: User-facing errors or warnings reported by the module.

    These are separate from `filename` for two reasons: 1) a convenience for
    module authors; and 2) so we can run SQL to find common problems.

    """

    __slots__ = (
        'filename',
        'errors',
    )


    def __init__(self, filename=None, errors=None,):
        self.filename = filename
        self.errors = errors

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.filename = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.errors = []
                    (_etype51, _size48) = iprot.readListBegin()
                    for _i52 in range(_size48):
                        _elem53 = RenderError()
                        _elem53.read(iprot)
                        self.errors.append(_elem53)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('FetchResult')
        if self.filename is not None:
            oprot.writeFieldBegin('filename', TType.STRING, 1)
            oprot.writeString(self.filename.encode('utf-8') if sys.version_info[0] == 2 else self.filename)
            oprot.writeFieldEnd()
        if self.errors is not None:
            oprot.writeFieldBegin('errors', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.errors))
            for iter54 in self.errors:
                iter54.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class RenderRequest(object):
    """
    Parameters to `render()`.

    Attributes:
     - basedir: Directory on disk where all filenames in this request are to be found.

    The RenderResponse file is expected to be written here, too.

    Here's a way to safely reuse this directory after every render(): when
    sandboxing, mount an OverlayFS with all the input files as read-only,
    then overlay-mount a "scratch" directory for the module to use (and
    write to `output_filename`).
     - input_table: Output from previous Step.

    This is zero-row, zero-column on the first Step in a Tab.
     - params: User-supplied parameters; must match the module's param_spec.

    `File` params are passed as strings, pointing to temporary files in
    `basedir`.
     - tab: Description of tab being rendered.
     - fetch_result: Result of latest `fetch`.

    If unset, `fetch` was never called.

    `fetch_result.filename` will point to a temporary file in `basedir`.
     - output_filename: File where the result Arrow table should be written.

    The caller is assumed to have made a best effort to ensure the file is
    writable.

    The file on disk will be in `basedir`.

    """

    __slots__ = (
        'basedir',
        'input_table',
        'params',
        'tab',
        'fetch_result',
        'output_filename',
    )


    def __init__(self, basedir=None, input_table=None, params=None, tab=None, fetch_result=None, output_filename=None,):
        self.basedir = basedir
        self.input_table = input_table
        self.params = params
        self.tab = tab
        self.fetch_result = fetch_result
        self.output_filename = output_filename

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.basedir = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.input_table = ArrowTable()
                    self.input_table.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.MAP:
                    self.params = {}
                    (_ktype56, _vtype57, _size55) = iprot.readMapBegin()
                    for _i59 in range(_size55):
                        _key60 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val61 = ParamValue()
                        _val61.read(iprot)
                        self.params[_key60] = _val61
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.tab = Tab()
                    self.tab.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.fetch_result = FetchResult()
                    self.fetch_result.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.output_filename = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RenderRequest')
        if self.basedir is not None:
            oprot.writeFieldBegin('basedir', TType.STRING, 1)
            oprot.writeString(self.basedir.encode('utf-8') if sys.version_info[0] == 2 else self.basedir)
            oprot.writeFieldEnd()
        if self.input_table is not None:
            oprot.writeFieldBegin('input_table', TType.STRUCT, 2)
            self.input_table.write(oprot)
            oprot.writeFieldEnd()
        if self.params is not None:
            oprot.writeFieldBegin('params', TType.MAP, 3)
            oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.params))
            for kiter62, viter63 in self.params.items():
                oprot.writeString(kiter62.encode('utf-8') if sys.version_info[0] == 2 else kiter62)
                viter63.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.tab is not None:
            oprot.writeFieldBegin('tab', TType.STRUCT, 4)
            self.tab.write(oprot)
            oprot.writeFieldEnd()
        if self.fetch_result is not None:
            oprot.writeFieldBegin('fetch_result', TType.STRUCT, 5)
            self.fetch_result.write(oprot)
            oprot.writeFieldEnd()
        if self.output_filename is not None:
            oprot.writeFieldBegin('output_filename', TType.STRING, 6)
            oprot.writeString(self.output_filename.encode('utf-8') if sys.version_info[0] == 2 else self.output_filename)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class RenderResult(object):
    """
    The module executed a Step's render() without crashing.

    An "ok" result may be a user-friendly error -- that is, a zero-column table
    and non-empty `errors`.

    Attributes:
     - table: Table the Step outputs.

    If the Step output is "error, then the table must have zero columns.

    The kernel writes the output Arrow data to `render_request.output_file`.
     - errors: User-facing errors or warnings reported by the module.
     - json: JSON to pass to the module's HTML, if it has HTML.

    This must be either an empty string, or a valid JSON value.

    """

    __slots__ = (
        'table',
        'errors',
        'json',
    )


    def __init__(self, table=None, errors=None, json="",):
        self.table = table
        self.errors = errors
        self.json = json

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.table = ArrowTable()
                    self.table.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.errors = []
                    (_etype67, _size64) = iprot.readListBegin()
                    for _i68 in range(_size64):
                        _elem69 = RenderError()
                        _elem69.read(iprot)
                        self.errors.append(_elem69)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.json = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RenderResult')
        if self.table is not None:
            oprot.writeFieldBegin('table', TType.STRUCT, 1)
            self.table.write(oprot)
            oprot.writeFieldEnd()
        if self.errors is not None:
            oprot.writeFieldBegin('errors', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.errors))
            for iter70 in self.errors:
                iter70.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.json is not None:
            oprot.writeFieldBegin('json', TType.STRING, 3)
            oprot.writeString(self.json.encode('utf-8') if sys.version_info[0] == 2 else self.json)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(ValidateModuleResult)
ValidateModuleResult.thrift_spec = (
)
all_structs.append(ColumnTypeText)
ColumnTypeText.thrift_spec = (
)
all_structs.append(ColumnTypeNumber)
ColumnTypeNumber.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'format', 'UTF8', "{:,}", ),  # 1
)
all_structs.append(ColumnTypeDatetime)
ColumnTypeDatetime.thrift_spec = (
)
all_structs.append(ColumnType)
ColumnType.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'text_type', [ColumnTypeText, None], None, ),  # 1
    (2, TType.STRUCT, 'number_type', [ColumnTypeNumber, None], None, ),  # 2
    (3, TType.STRUCT, 'datetime_type', [ColumnTypeDatetime, None], None, ),  # 3
)
all_structs.append(Column)
Column.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'type', [ColumnType, None], None, ),  # 2
)
all_structs.append(TableMetadata)
TableMetadata.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'n_rows', None, None, ),  # 1
    (2, TType.LIST, 'columns', (TType.STRUCT, [Column, None], False), None, ),  # 2
)
all_structs.append(ArrowTable)
ArrowTable.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'filename', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'metadata', [TableMetadata, None], None, ),  # 2
)
all_structs.append(ParamValue)
ParamValue.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'string_value', 'UTF8', None, ),  # 1
    (2, TType.I64, 'integer_value', None, None, ),  # 2
    (3, TType.DOUBLE, 'float_value', None, None, ),  # 3
    (4, TType.BOOL, 'boolean_value', None, None, ),  # 4
    (5, TType.STRUCT, 'column_value', [Column, None], None, ),  # 5
    (6, TType.STRUCT, 'tab_value', [TabOutput, None], None, ),  # 6
    (7, TType.LIST, 'list_value', (TType.STRUCT, [ParamValue, None], False), None, ),  # 7
    (8, TType.MAP, 'map_value', (TType.STRING, 'UTF8', TType.STRUCT, [ParamValue, None], False), None, ),  # 8
    (9, TType.STRING, 'filename_value', 'UTF8', None, ),  # 9
)
all_structs.append(RawParams)
RawParams.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'json', 'UTF8', None, ),  # 1
)
all_structs.append(Tab)
Tab.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'slug', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'name', 'UTF8', None, ),  # 2
)
all_structs.append(TabOutput)
TabOutput.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'tab', [Tab, None], None, ),  # 1
    (2, TType.STRUCT, 'table', [ArrowTable, None], None, ),  # 2
)
all_structs.append(I18nArgument)
I18nArgument.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'string_value', 'UTF8', None, ),  # 1
    (2, TType.I32, 'i32_value', None, None, ),  # 2
    (3, TType.DOUBLE, 'double_value', None, None, ),  # 3
)
all_structs.append(I18nMessageSource)
I18nMessageSource.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'library', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'module_id', 'UTF8', None, ),  # 2
)
all_structs.append(I18nMessage)
I18nMessage.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'id', 'UTF8', None, ),  # 1
    (2, TType.MAP, 'arguments', (TType.STRING, 'UTF8', TType.STRUCT, [I18nArgument, None], False), None, ),  # 2
    (3, TType.STRUCT, 'source', [I18nMessageSource, None], None, ),  # 3
)
all_structs.append(PrependStepQuickFixAction)
PrependStepQuickFixAction.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'module_slug', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'partial_params', [RawParams, None], None, ),  # 2
)
all_structs.append(QuickFixAction)
QuickFixAction.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'prepend_step', [PrependStepQuickFixAction, None], None, ),  # 1
)
all_structs.append(QuickFix)
QuickFix.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'button_text', [I18nMessage, None], None, ),  # 1
    (2, TType.STRUCT, 'action', [QuickFixAction, None], None, ),  # 2
)
all_structs.append(RenderError)
RenderError.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'message', [I18nMessage, None], None, ),  # 1
    (2, TType.LIST, 'quick_fixes', (TType.STRUCT, [QuickFix, None], False), None, ),  # 2
)
all_structs.append(FetchRequest)
FetchRequest.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'basedir', 'UTF8', None, ),  # 1
    (2, TType.MAP, 'params', (TType.STRING, 'UTF8', TType.STRUCT, [ParamValue, None], False), None, ),  # 2
    (3, TType.STRUCT, 'secrets', [RawParams, None], None, ),  # 3
    (4, TType.STRUCT, 'last_fetch_result', [FetchResult, None], None, ),  # 4
    (5, TType.STRING, 'input_table_parquet_filename', 'UTF8', None, ),  # 5
    (6, TType.STRING, 'output_filename', 'UTF8', None, ),  # 6
)
all_structs.append(FetchResult)
FetchResult.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'filename', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'errors', (TType.STRUCT, [RenderError, None], False), None, ),  # 2
)
all_structs.append(RenderRequest)
RenderRequest.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'basedir', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'input_table', [ArrowTable, None], None, ),  # 2
    (3, TType.MAP, 'params', (TType.STRING, 'UTF8', TType.STRUCT, [ParamValue, None], False), None, ),  # 3
    (4, TType.STRUCT, 'tab', [Tab, None], None, ),  # 4
    (5, TType.STRUCT, 'fetch_result', [FetchResult, None], None, ),  # 5
    (6, TType.STRING, 'output_filename', 'UTF8', None, ),  # 6
)
all_structs.append(RenderResult)
RenderResult.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'table', [ArrowTable, None], None, ),  # 1
    (2, TType.LIST, 'errors', (TType.STRUCT, [RenderError, None], False), None, ),  # 2
    (3, TType.STRING, 'json', 'UTF8', "", ),  # 3
)
fix_spec(all_structs)
del all_structs
